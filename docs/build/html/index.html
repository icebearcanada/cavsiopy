<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Welcome to cavsiopy’s documentation! &mdash; cavsiopy 0.9.10 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="#" class="icon icon-home">
            cavsiopy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Welcome to cavsiopy’s documentation!</a></li>
<li><a class="reference internal" href="#module-ephemeris_importer">ephemeris_importer: module to import RRI ephemeris and Celestrak TLE</a></li>
<li><a class="reference internal" href="#module-use_rotation_matrices">use_rotation_matrices: Module to rotate instrument and transform between reference frame</a></li>
<li><a class="reference internal" href="#module-attitude_analysis">attitude_analysis: Module to obtain instrument pointing direction in NEC and NED</a></li>
<li><a class="reference internal" href="#module-attitude_plotter">attitude_plotter: Module to visualize satellite instrument pointing direction</a></li>
<li><a class="reference internal" href="#miscellaneous-utilities">miscellaneous: Utilities</a></li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">cavsiopy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Welcome to cavsiopy’s documentation!</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="welcome-to-cavsiopy-s-documentation">
<h1>Welcome to cavsiopy’s documentation!<a class="headerlink" href="#welcome-to-cavsiopy-s-documentation" title="Permalink to this heading"></a></h1>
<p># cavsiopy: Calculation and Visualization of Spacecraft Instrument Orientation</p>
<p>## Description:
cavsiopy imports the ephemerides and attitude information (roll, pitch, yaw) of the spacecraft and determines the pointing direction of an instrument onboard.</p>
<p>## Table of Contents:
This package contains routines for
1. Rotating the look direction of an instrument on-board the spacecraft in orbital frame (rotate_instrument)
2. Calculation of the look angles of the spacecraft (elevation and azimuth) (LA_sat)
3. Calculation of the look angles of the instrument (elevation and azimuth) (LA_inst)
4. Calculation of the distance between the spacecraft and a designated point on the ground (spacecraft_distance_from_a_point)
5. Calculation of the line-of-sight direction vector from the target to the spacecraft location (calculate_los_vec)
6. Transformations between GEI J2K, ECEF, NED, NEC, ICRF, ITRF reference frames (find_instrument_attitude)
7. Visualization of spacecraft and instrument direction in 2D and 3D (simple or overlaid on geographical regions of the Earth below the satellite trajectory) (attitude_plotter module)
8. Rotation matrices for rotations by x, y, z axes</p>
<p>Instrument pointing direction vectors can be obtained in GEI J2K, ECEF, NED, NEC, ICRF, ITRF.</p>
<p>## Requirements:
numpy, matplotlib, astropy, cartopy, geopy, h5py, pysofa</p>
<p>## Installation:
before installing cavsiopy some of the dependencies need special installation instructions:</p>
<p>### cartopy:
* If you are installing cartopy via pip (on Ubuntu/Debian) first libgeos-dev has to be on your system:</p>
<blockquote>
<div><p>sudo apt -y install libgeos-dev</p>
<p>pip3 install cartopy</p>
</div></blockquote>
<ul>
<li><p>Follow the installation guide for other systems: <a class="reference external" href="https://scitools.org.uk/cartopy/docs/latest/installing.html">https://scitools.org.uk/cartopy/docs/latest/installing.html</a></p></li>
<li><p>for installation of cartopy with conda:</p>
<p>conda install -c conda-forge cartopy</p>
</li>
</ul>
<p>### pysofa:
pysofa is the Python wrapper for the Standards of Fundamental Astronomy (SOFA)  written by Brian Kloppenborg.
cavsiopy depends on pysofa for determining the ICRF to ITRF rotation matrix.</p>
<p>Here we follow (<a class="reference external" href="https://kloppenborg.net/blog/building-sofa-for-pysofa/">https://kloppenborg.net/blog/building-sofa-for-pysofa/</a>) for pysofa installation:</p>
<p>sudo apt-get install python python-all-dev build-essential cmake</p>
<p>Download and extract SOFA from the official download page (<a class="reference external" href="https://www.iausofa.org/2010_1201_C/sofa_c-20101201.tar.gz">https://www.iausofa.org/2010_1201_C/sofa_c-20101201.tar.gz</a>)</p>
<p>After extracting SOFA, cd into the main directory and create a CMakeLists.txt file with the following content:</p>
<p>cmake_minimum_required(VERSION 2.6)</p>
<p>project(sofa_c C)</p>
<p>####  Set a few variables:
set(LIBS ${LIBS} m)</p>
<p>#### Extract all of the source files:
file(GLOB_RECURSE C_SOURCE . src/<a href="#id1"><span class="problematic" id="id2">*</span></a>.c)</p>
<p>#### Build a shared library:
add_library(sofa_c SHARED ${C_SOURCE})</p>
<p>#### Now define the installation options:
install(TARGETS sofa_c LIBRARY DESTINATION lib)</p>
<p>cmake .</p>
<p>make</p>
<p>make install</p>
<p>sudo ldconfig</p>
<p>#### you may need some more tweaking for pysofa</p>
<ol class="arabic simple">
<li><p>ModuleNotFoundError: No module named ‘pysofa_ctypes’</p></li>
</ol>
<blockquote>
<div><p>copy the contents of pysofa_ctypes to __init__.py</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><dl class="simple">
<dt>if __sofa_version &lt; (2010, 12, 01):</dt><dd><p>^</p>
</dd>
</dl>
</li>
</ol>
<blockquote>
<div><p>SyntaxError: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers</p>
<p>find and replace all 2010, 12, 01 with 2010, 12, 1 in __init__.py</p>
</div></blockquote>
<p>### other packages and requirements:
pip install –no-deps astropy</p>
<p>pip install geopy</p>
<p>pip install -r requirements.txt</p>
<p>### now, we are good to go!</p>
<p>pip install cavsiopy</p>
<p>Credits: C. Eyiguler, Warren Holley, Andrew D. Howarth, Donald W. Danskin, Kuldeep Pandey, Carley Martin</p>
<p>Contributing: Glenn C. Hussey, Robert Gillies, Andrew W. Yau</p>
<p>License: GNU LESSER GENERAL PUBLIC LICENSE Version 3, 29 June 2007</p>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
<div class="toctree-wrapper compound">
</div>
</section>
<section id="module-ephemeris_importer">
<span id="ephemeris-importer-module-to-import-rri-ephemeris-and-celestrak-tle"></span><h1>ephemeris_importer: module to import RRI ephemeris and Celestrak TLE<a class="headerlink" href="#module-ephemeris_importer" title="Permalink to this heading"></a></h1>
<p>ephemeris_importer module imports several types of data files to obtain 
spacecraft ephemeris. Values are returned as Python dictionaries.</p>
<p>Swarm-E specific data files are: CAS_ephemeris, Cas_AttQUAT, and RRI
files standard for all spacecraft: sp3, TLE</p>
<p>ephemeris_importer also includes functions to compute satellite orbital 
elements using GEIJ2K position and velocity (calculate_orbital_elements), 
and to compare computed values with data in TLE file (compare_orbital).</p>
<div class="toctree-wrapper compound">
</div>
<p>&#64;author: ceren</p>
<dl class="py function">
<dt class="sig sig-object py" id="ephemeris_importer.calculate_orbital_elements">
<span class="sig-prename descclassname"><span class="pre">ephemeris_importer.</span></span><span class="sig-name descname"><span class="pre">calculate_orbital_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pX</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pY</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pZ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vz</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ephemeris_importer.calculate_orbital_elements" title="Permalink to this definition"></a></dt>
<dd><p>Calculates satellite orbital parameters using X, Y, Z, Vx, Vy, Vz in GEIJ2K</p>
<p>Reference: Curtis, H. D. (2014). Orbits in Three Dimensions in 
Orbital mechanics for engineering students. Butterworth-Heinemann.</p>
<dl class="simple">
<dt>pX<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>X position in GEIJ2K (km)</p>
</dd>
<dt>pY<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Y position in GEIJ2K (km)</p>
</dd>
<dt>pZ<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Z position in GEIJ2K (km)</p>
</dd>
<dt>Vx<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>X component of velocity in GEIJ2K (km/s)</p>
</dd>
<dt>Vy<span class="classifier">Tnumpy.ndarray[float]</span></dt><dd><p>Y component of velocity in GEIJ2K (km/s)</p>
</dd>
<dt>Vz<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Z component of velocity in GEIJ2K (km/s)</p>
</dd>
</dl>
<dl class="simple">
<dt>inc<span class="classifier">float</span></dt><dd><p>satellite inclination (radian)</p>
</dd>
<dt>raan<span class="classifier">float</span></dt><dd><p>Right ascension of ascending node (radian)</p>
</dd>
<dt>ap<span class="classifier">float</span></dt><dd><p>Argument of periapsis (radian)</p>
</dd>
<dt>e<span class="classifier">float</span></dt><dd><p>eccentricity (radian)</p>
</dd>
<dt>TA<span class="classifier">float</span></dt><dd><p>True anomaly (radian)</p>
</dd>
</dl>
<p>sat_inc, sat_ap, sat_raan, sat_ecc, sat_TA =         ei.calculate_orbital_elements(dict_rri[‘GEIx’], dict_rri[‘GEIy’],                                       dict_rri[‘GEIz’], dict_rri[‘GEIVx’],                                           dict_rri[‘GEIVy’], dict_rri[‘GEIVz’])</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ephemeris_importer.cas_ephemeris">
<span class="sig-prename descclassname"><span class="pre">ephemeris_importer.</span></span><span class="sig-name descname"><span class="pre">cas_ephemeris</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_cas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_end</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ephemeris_importer.cas_ephemeris" title="Permalink to this definition"></a></dt>
<dd><p>Imports CAS_ephemeris files of Swarm-E:
Ref:(https://epop.phys.ucalgary.ca/data-handbook/cas-ephemeris-text-files/)</p>
<p>Extracts satellite ephemeris info for the experiment time interval
specified by time_start and time_end.</p>
<dl class="simple">
<dt>file_cas<span class="classifier">str</span></dt><dd><p>file name including path</p>
</dd>
<dt>time_start<span class="classifier">datetime.datetime</span></dt><dd><p>start of the experiment</p>
</dd>
<dt>time_end<span class="classifier">datetime.datetime</span></dt><dd><p>end of the experiment</p>
</dd>
</dl>
<dl>
<dt>dict<span class="classifier">dict</span></dt><dd><p>keys and properties listed below
srow : int</p>
<blockquote>
<div><p>row of the start time in the cas_ephemeris file</p>
</div></blockquote>
<dl class="simple">
<dt>erow<span class="classifier">int</span></dt><dd><p>row of the end time in the cas_ephemeris file</p>
</dd>
<dt>start<span class="classifier">datetime.datetime</span></dt><dd><p>start time in CAS_ephemeris file</p>
</dd>
<dt>end<span class="classifier">datetime.datetime</span></dt><dd><p>end time in CAS_ephemeris file</p>
</dd>
<dt>time_array<span class="classifier">datetime.datetime</span></dt><dd><p>time of the observations</p>
</dd>
<dt>Lat<span class="classifier">np.array[float]</span></dt><dd><p>Geodetic latitude</p>
</dd>
<dt>Lon<span class="classifier">np.array[float]</span></dt><dd><p>Geodetic longitude</p>
</dd>
<dt>Alt<span class="classifier">np.array[float]</span></dt><dd><p>geodetic altitude (km)</p>
</dd>
<dt>MLat: np.array[float]</dt><dd><p>Magnetic latitude (deg)</p>
</dd>
<dt>MLon: np.array[float]</dt><dd><p>Magnetic longitude (deg)</p>
</dd>
<dt>MLT: np.array[float]</dt><dd><p>Magnetic local time (h)</p>
</dd>
<dt>GEIx<span class="classifier">np.array[float]</span></dt><dd><p>Spacecraft position in GEI coordinates (X-km)</p>
</dd>
<dt>GEIy<span class="classifier">np.array[float]</span></dt><dd><p>Spacecraft position in GEI coordinates (Y-km)</p>
</dd>
<dt>GEIz<span class="classifier">np.array[float]</span></dt><dd><p>Spacecraft position in GEI coordinates (Z-km)</p>
</dd>
<dt>GEIVx<span class="classifier">np.array[float]</span></dt><dd><p>X component of the spacecraft velocity in GEI coordinates (Vx-km/s)</p>
</dd>
<dt>GEIVy<span class="classifier">np.array[float]</span></dt><dd><p>Y component of the spacecraft velocity in GEI coordinates (Vy-km/s)</p>
</dd>
<dt>GEIVz<span class="classifier">np.array[float]</span></dt><dd><p>Z component of the spacecraft velocity in GEI coordinates (Vz-km/s)</p>
</dd>
<dt>GSMx<span class="classifier">np.array[float]</span></dt><dd><p>Spacecraft position in GEI coordinates (X-km)</p>
</dd>
<dt>GSMy<span class="classifier">np.array[float]</span></dt><dd><p>Spacecraft position in GEI coordinates (Y-km)</p>
</dd>
<dt>GSMz<span class="classifier">np.array[float]</span></dt><dd><p>Spacecraft position in GEI coordinates (Z-km)</p>
</dd>
<dt>roll<span class="classifier">np.array[float]</span></dt><dd><p>roll angle; rotation around x axis (degrees)</p>
</dd>
<dt>pitch<span class="classifier">np.array[float]</span></dt><dd><p>pitch angle; rotation around y axis (degrees)</p>
</dd>
<dt>yaw<span class="classifier">np.array[float]</span></dt><dd><p>yaw angle; rotation around z axis (degrees)</p>
</dd>
<dt>acc<span class="classifier">int</span></dt><dd><p>accuracy of the attitude solution 
(0 = Dropout, 1 = Rough, 2 = Coarse, 3 = Moderate,  4 = Fine)</p>
</dd>
</dl>
</dd>
</dl>
<p>dict_cas = ei.cas_ephemeris(file_CAS, time_start, time_end)
GEIx = dict_cas[‘GEIx’]</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ephemeris_importer.compare_orbital">
<span class="sig-prename descclassname"><span class="pre">ephemeris_importer.</span></span><span class="sig-name descname"><span class="pre">compare_orbital</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_TLE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filedate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">DOY</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pX</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pY</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pZ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vz</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ephemeris_importer.compare_orbital" title="Permalink to this definition"></a></dt>
<dd><p>Compares values from the TLE file with the calculated average TLE values.
Prints out the comparison results.</p>
<p>inc: spacecraft inclination angle
raan: right ascension of ascending node
ap: argument of periapsis</p>
<dl class="simple">
<dt>file_TLE: str</dt><dd><p>filename for TLE file (including path).</p>
</dd>
<dt>filedate: str</dt><dd><p>date of RRI passage, format: ‘%H%M%S’.</p>
</dd>
<dt>DOY: int </dt><dd><p>day of year of RRI passage.</p>
</dd>
<dt>pX<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>X position in GEIJ2K (km).</p>
</dd>
<dt>pY<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Y position in GEIJ2K (km).</p>
</dd>
<dt>pZ<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Z position in GEIJ2K (km).</p>
</dd>
<dt>Vx<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>X component of velocity in GEIJ2K (km/s).</p>
</dd>
<dt>Vy<span class="classifier">Tnumpy.ndarray[float]</span></dt><dd><p>Y component of velocity in GEIJ2K (km/s).</p>
</dd>
<dt>Vz<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Z component of velocity in GEIJ2K (km/s).</p>
</dd>
</dl>
<dl class="simple">
<dt>sap_comp<span class="classifier">Tuple[float, float, float]</span></dt><dd><p>Element1: the difference between the tle and computed inclination (deg) 
Element2: the difference between the tle and computed raan (deg) 
Element3: the difference between the tle and computed ap (deg)</p>
</dd>
</dl>
<p>time_start = datetime.datetime(2016, 4, 18, 22, 27, 59) 
DOY = time_start.timetuple().tm_yday
filedate = ‘20160418’
comp = ei.compare_orbital(file_TLE, filedate, DOY, dict_rri[‘GEIx’],</p>
<blockquote>
<div><p>dict_rri[‘GEIy’], dict_rri[‘GEIz’], 
dict_rri[‘GEIVx’], dict_rri[‘GEIVy’], 
dict_rri[‘GEIVz’])</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ephemeris_importer.import_tle">
<span class="sig-prename descclassname"><span class="pre">ephemeris_importer.</span></span><span class="sig-name descname"><span class="pre">import_tle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filedate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">DOY</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ephemeris_importer.import_tle" title="Permalink to this definition"></a></dt>
<dd><p>Reads Celestrak TLE file</p>
<p>File obtained from: <a class="reference external" href="https://celestrak.com/">https://celestrak.com/</a></p>
<dl class="simple">
<dt>filename: str</dt><dd><p>filename for TLE file.</p>
</dd>
<dt>filedate: str</dt><dd><p>date of RRI passage.</p>
</dd>
<dt>DOY: int </dt><dd><p>day of year of RRI passage.</p>
</dd>
</dl>
<dl class="simple">
<dt>tle_epoch<span class="classifier">float</span></dt><dd><p>epoch of TLE file.</p>
</dd>
<dt>tle_inc<span class="classifier">float</span></dt><dd><p>satellite inclination (degrees).</p>
</dd>
<dt>tle_ap<span class="classifier">float</span></dt><dd><p>satellite argument of perigee (degrees).</p>
</dd>
<dt>tle_raan<span class="classifier">float</span></dt><dd><p>right ascension of ascending node (degrees).</p>
</dd>
<dt>tle_ecc<span class="classifier">int</span></dt><dd><p>orbit eccentricity.</p>
</dd>
<dt>tle_ma<span class="classifier">float</span></dt><dd><p>mean anomaly (degrees).</p>
</dd>
</dl>
<p>time_start = datetime.datetime(2016, 4, 18, 22, 27, 59) 
DOY = time_start.timetuple().tm_yday
filedate = ‘20160418’    
tle_epoch, tle_inc, tle_ap, tle_raan, tle_ecc, tle_ma =         ei.import_tle(file_TLE, filedate, DOY)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ephemeris_importer.rri_ephemeris">
<span class="sig-prename descclassname"><span class="pre">ephemeris_importer.</span></span><span class="sig-name descname"><span class="pre">rri_ephemeris</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_rri</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ephemeris_importer.rri_ephemeris" title="Permalink to this definition"></a></dt>
<dd><p>Imports rri_ephemeris and returns the ephemeris information within a 
dictionary.</p>
<p>Dictionary keys are listed below:</p>
<dl class="simple">
<dt>file_rri<span class="classifier">TYPE</span></dt><dd><p>RRI file name including path</p>
</dd>
</dl>
<dl>
<dt>dict:</dt><dd><p>keys and properties of the keys are below:
time_data : np.array[float]</p>
<blockquote>
<div><p>seconds since May 24, 1968.</p>
</div></blockquote>
<dl class="simple">
<dt>time_array<span class="classifier">datetime.datetime</span></dt><dd><p>time of the observations</p>
</dd>
<dt>start_time<span class="classifier">datetime.datetime</span></dt><dd><p>start_time of the experiment</p>
</dd>
<dt>end_time<span class="classifier">datetime.datetime</span></dt><dd><p>end time of the experiment</p>
</dd>
<dt>Lat<span class="classifier">np.array[float]</span></dt><dd><p>Geodetic latitude</p>
</dd>
<dt>Lon<span class="classifier">np.array[float]</span></dt><dd><p>Geodetic longitude</p>
</dd>
<dt>Alt<span class="classifier">np.array[float]</span></dt><dd><p>geodetic altitude (km)</p>
</dd>
<dt>MLat: np.array[float]</dt><dd><p>Magnetic latitude (deg)</p>
</dd>
<dt>MLon: np.array[float]</dt><dd><p>Magnetic longitude (deg)</p>
</dd>
<dt>MLT: np.array[float]</dt><dd><p>Magnetic local time (h)</p>
</dd>
<dt>GEOx<span class="classifier">np.array[float]</span></dt><dd><p>Spacecraft position in GEO coordinates (X-km)</p>
</dd>
<dt>GEOy<span class="classifier">np.array[float]</span></dt><dd><p>Spacecraft position in GEO coordinates (Y-km)</p>
</dd>
<dt>GEOz<span class="classifier">np.array[float]</span></dt><dd><p>Spacecraft position in GEO coordinates (Z-km)</p>
</dd>
<dt>GEOVx<span class="classifier">np.array[float]</span></dt><dd><p>X component of the spacecraft velocity in GEO coordinates (Vx-km/s)</p>
</dd>
<dt>GEOVy<span class="classifier">np.array[float]</span></dt><dd><p>Y component of the spacecraft velocity in GEO coordinates (Vy-km/s)</p>
</dd>
<dt>GEOVz<span class="classifier">np.array[float]</span></dt><dd><p>Z component of the spacecraft velocity in GEO coordinates (Vz-km/s)</p>
</dd>
<dt>GEIx<span class="classifier">np.array[float]</span></dt><dd><p>Spacecraft position in GEI coordinates (X-km)</p>
</dd>
<dt>GEIy<span class="classifier">np.array[float]</span></dt><dd><p>Spacecraft position in GEI coordinates (Y-km)</p>
</dd>
<dt>GEIz<span class="classifier">np.array[float]</span></dt><dd><p>Spacecraft position in GEI coordinates (Z-km)</p>
</dd>
<dt>GEIVx<span class="classifier">np.array[float]</span></dt><dd><p>X component of the spacecraft velocity in GEI coordinates (Vx-km/s)</p>
</dd>
<dt>GEIVy<span class="classifier">np.array[float]</span></dt><dd><p>Y component of the spacecraft velocity in GEI coordinates (Vy-km/s)</p>
</dd>
<dt>GEIVz<span class="classifier">np.array[float]</span></dt><dd><p>Z component of the spacecraft velocity in GEI coordinates (Vz-km/s)</p>
</dd>
<dt>roll<span class="classifier">np.array[float]</span></dt><dd><p>roll angle; rotation around x axis (degrees)</p>
</dd>
<dt>pitch<span class="classifier">np.array[float]</span></dt><dd><p>pitch angle; rotation around y axis (degrees)</p>
</dd>
<dt>yaw<span class="classifier">np.array[float]</span></dt><dd><p>yaw angle; rotation around z axis (degrees)</p>
</dd>
<dt>accuracy<span class="classifier">int</span></dt><dd><p>accuracy of the attitude solution 
(0 = Dropout, 1 = Rough, 2 = Coarse, 3 = Moderate,  4 = Fine)</p>
</dd>
</dl>
</dd>
</dl>
<p>dict_rri = ei.rri_ephemeris(file_RRI)
Lat = dict_rri[‘Lat’]</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ephemeris_importer.sp3_ephemeris">
<span class="sig-prename descclassname"><span class="pre">ephemeris_importer.</span></span><span class="sig-name descname"><span class="pre">sp3_ephemeris</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_SP3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_date</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ephemeris_importer.sp3_ephemeris" title="Permalink to this definition"></a></dt>
<dd><p>imports position and velocity data in the International Terrestrial 
Reference Frame (ITRF) from the sp3 data file:</p>
<p>Ref: (<a class="reference external" href="https://epop.phys.ucalgary.ca/data-handbook/orbit-geo-sp3-file/">https://epop.phys.ucalgary.ca/data-handbook/orbit-geo-sp3-file/</a>)</p>
<p>Extracts satellite ephemeris info for the experiment time interval
specified by time_start and time_end.</p>
<dl class="simple">
<dt>file_SP3<span class="classifier">str</span></dt><dd><p>SP3 filename with file path</p>
</dd>
<dt>start_date<span class="classifier">datetime.datetime</span></dt><dd><p>beginning of the data sampling interval</p>
</dd>
<dt>end_date<span class="classifier">datetime.datetime</span></dt><dd><p>end of the data sampling interval</p>
</dd>
</dl>
<dl>
<dt>dict<span class="classifier">dict </span></dt><dd><p>keys and properties listed below
ITRFx : np.array[float]</p>
<blockquote>
<div><p>Spacecraft position in ITRF coordinates (X-km)</p>
</div></blockquote>
<dl class="simple">
<dt>ITRFy<span class="classifier">np.array[float]</span></dt><dd><p>Spacecraft position in ITRF coordinates (Y-km)</p>
</dd>
<dt>ITRFz<span class="classifier">np.array[float]</span></dt><dd><p>Spacecraft position in ITRF coordinates (Z-km)</p>
</dd>
<dt>ITRFVx<span class="classifier">np.array[float]</span></dt><dd><p>X component of the spacecraft velocity in ITRF coordinates(Vx-km/s)</p>
</dd>
<dt>ITRFVy<span class="classifier">np.array[float]</span></dt><dd><p>Y component of the spacecraft velocity in ITRF coordinates(Vy-km/s)</p>
</dd>
<dt>ITRFVz<span class="classifier">np.array[float]</span></dt><dd><p>Z component of the spacecraft velocity in ITRF coordinates(Vz-km/s)</p>
</dd>
</dl>
</dd>
</dl>
<p>dict_sp3 = ei.sp3_ephemeris(file_SP3, start_date, end_date)
ITRFx = dict_sp3[‘ITRFx’]</p>
</dd></dl>

</section>
<section id="module-use_rotation_matrices">
<span id="use-rotation-matrices-module-to-rotate-instrument-and-transform-between-reference-frame"></span><h1>use_rotation_matrices: Module to rotate instrument and transform between reference frame<a class="headerlink" href="#module-use_rotation_matrices" title="Permalink to this heading"></a></h1>
<p>use_rotation_matrices contains functions to  
1. calculate the GMST time from noon or midnight
2. rotate the RRI in orbital frame using roll, pitch, and yaw angles using 
RPY sequential order
3. compute the rotation matrices for the transformations between 
spacecraft orbital frame(ORF) and GEI J2000, J2K and ECEF, J2K and ITRF, 
ECEF and NED, ITRF and NEC, ITRF and NED, and  NED and ENU.</p>
<p>Two sets of rotation matrices are provided to build up direction cosine matrix.
1. SET-1:
According to Coordinate Transformations via Euler Angles, Riggs, 2019. Rev. E.
expresses the inertial frame vectors in terms of rotated frame vectors
used for transformation from a rotated frame to inertial frame
gives i, j, k in terms of i’, j’, k’; abbreviated as r2i in the code
definition of the reference: x (out), y (right), and z (up)</p>
<p>ROLL: positive is from +Y towards +Z
PITCH: positive is from +Z towards +X
YAW: positive is from +X towards +Y</p>
<p>2. SET-2:
According to Curtis, H. D. (2013). Orbital mechanics for engineering students.
expresses the rotated frame vectors in terms of inertial frame vectors
for transformation from an inertial frame to rotated frame
gives i’, j’, k’ in terms of i, j, k; abbreviated as i2r in the code
RRI description: x (out), y (right), and z (down)</p>
<p>ROLL: positive is from +Y towards +Z
PITCH: positive is from +Z towards +X
YAW: positive is from +X towards +Y</p>
<p>&#64;author: ceren</p>
<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.GMST_midnight">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">GMST_midnight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">utc_dt_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.GMST_midnight" title="Permalink to this definition"></a></dt>
<dd><p>Calculates GMST in degrees.</p>
<p>Includes day fraction corrected with respect to midnight.</p>
<p>Follows: Curtis, H. D. (2013). Orbital mechanics for engineering students.
Butterworth-Heinemann. This formula gives GMST in degrees.</p>
<dl class="simple">
<dt>utc_dt_array: datetime.datetime</dt><dd><p>time array in UTC</p>
</dd>
</dl>
<dl class="simple">
<dt>GMST: float</dt><dd><p>GMST in radians</p>
</dd>
</dl>
<p>GMST = calculate_GMST_midnight(utc_dt_array)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.GMST_noon">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">GMST_noon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.GMST_noon" title="Permalink to this definition"></a></dt>
<dd><p>Follows: Curtis, H. D. (2013). Orbital mechanics for engineering students.
Butterworth-Heinemann. This formula gives GMST in degrees.</p>
<p>Includes day fraction corrected with respect to noon.</p>
<dl class="simple">
<dt>time_array<span class="classifier">datetime.datetime</span></dt><dd><p>time array in UTC</p>
</dd>
</dl>
<dl class="simple">
<dt>GMST: float</dt><dd><p>GMST in radians</p>
</dd>
</dl>
<p>GMST = calculate_GMST_noon(time_array)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.RX_i2r">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">RX_i2r</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.RX_i2r" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>x<span class="classifier">float</span></dt><dd><p>roll angle (radians)</p>
</dd>
</dl>
<dl class="simple">
<dt>numpy.ndarray</dt><dd><p>Rotation matrix about x axis</p>
</dd>
</dl>
<p>Rx = RX_i2r(roll)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.RX_r2i">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">RX_r2i</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.RX_r2i" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>x<span class="classifier">float</span></dt><dd><p>roll angle (radians)</p>
</dd>
</dl>
<dl class="simple">
<dt>numpy.ndarray</dt><dd><p>Rotation matrix about x axis</p>
</dd>
</dl>
<p>Rx = RX_r2i(roll)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.RY_i2r">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">RY_i2r</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.RY_i2r" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>y<span class="classifier">float</span></dt><dd><p>pitch angle (radians)</p>
</dd>
</dl>
<dl class="simple">
<dt>numpy.ndarray</dt><dd><p>Rotation matrix about y axis</p>
</dd>
</dl>
<p>Ry = RY_i2r(pitch)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.RY_r2i">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">RY_r2i</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.RY_r2i" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>y<span class="classifier">float</span></dt><dd><p>pitch angle (radians)</p>
</dd>
</dl>
<dl class="simple">
<dt>numpy.ndarray</dt><dd><p>Rotation matrix about y axis</p>
</dd>
</dl>
<p>Ry = RY_r2i(pitch)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.RZ_i2r">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">RZ_i2r</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.RZ_i2r" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>z<span class="classifier">float</span></dt><dd><p>yaw angle (radians)</p>
</dd>
</dl>
<dl class="simple">
<dt>numpy.ndarray</dt><dd><p>Rotation matrix about z axis</p>
</dd>
</dl>
<p>Rz = RZ_i2r(yaw)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.RZ_r2i">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">RZ_r2i</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.RZ_r2i" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>z<span class="classifier">float</span></dt><dd><p>yaw angle (radians)</p>
</dd>
</dl>
<dl class="simple">
<dt>numpy.ndarray</dt><dd><p>Rotation matrix about z axis</p>
</dd>
</dl>
<p>Rz = RZ_r2i(yaw)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.ecef_to_gei_rm">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">ecef_to_gei_rm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta_rad</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.ecef_to_gei_rm" title="Permalink to this definition"></a></dt>
<dd><p>Function to calculate ECEF to GEI rotation matrix.</p>
<p>Uses the transpose of GEIJ2K to ECEF rotation matrix.</p>
<dl class="simple">
<dt>theta_rad<span class="classifier">float</span></dt><dd><p>GMST_midnight.</p>
</dd>
</dl>
<dl class="simple">
<dt>GEI2ECEF<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Rotation matrix for transformations from GEI to ECEF.</p>
</dd>
</dl>
<p>R = ecef_to_gei_rm(theta_rad)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.gei2ecef">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">gei2ecef</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inst_GEI</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.gei2ecef" title="Permalink to this definition"></a></dt>
<dd><p>function for GEIJ2K to ECEF transformations</p>
<dl class="simple">
<dt>inst_GEI<span class="classifier">np.ndarray[float]</span></dt><dd><p>instrument look direction in GEIJ2K</p>
</dd>
<dt>time_array<span class="classifier">datetime.datetime</span></dt><dd><p>experiment time interval</p>
</dd>
</dl>
<dl class="simple">
<dt>inst_ECEF<span class="classifier">np.ndarray[float]</span></dt><dd><p>instrument look direction in GEIJ2K</p>
</dd>
</dl>
<p>inst_ECEF = gei2ecef(inst_GEI, time_array)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.gei_to_ecef_rm">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">gei_to_ecef_rm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta_rad</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.gei_to_ecef_rm" title="Permalink to this definition"></a></dt>
<dd><p>Function to calculate the GEI to ECEF rotation matrix.</p>
<p>One rotation is needed in xy frame (yaw rotation) to transform from 
GEIJ2K to ECEF. yaw angle is the azimuth angle between GEIJ2K and 
ECEF in this case.</p>
<p>Azimuth= Greenwich sidereal time + Earth’s rotation speed * UTC.</p>
<p>Ref:
1. J. Riggs, Coordinate transformations via Euler Angle Rotations,
Rev. E - 10 April 2019
2. A. Sofyali, Orbital Mechanics notes, 7 February 2019.</p>
<dl class="simple">
<dt>theta_rad<span class="classifier">float</span></dt><dd><p>GMST_midnight.</p>
</dd>
</dl>
<dl class="simple">
<dt>GEI2ECEF<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Rotation matrix for transformations from GEI to ECEF.</p>
</dd>
</dl>
<p>R = gei_to_ecef_rm(theta_rad)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.gei_to_oe_rm">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">gei_to_oe_rm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ap</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.gei_to_oe_rm" title="Permalink to this definition"></a></dt>
<dd><p>Function to calculate the GEI to perifocal frame matrix.</p>
<p>GEI2OE matrix is the transpose of OE2GEI matrix.</p>
<dl class="simple">
<dt>inc<span class="classifier">float</span></dt><dd><p>satellite inclination (in radians).</p>
</dd>
<dt>raan<span class="classifier">float</span></dt><dd><p>satellite right ascension of ascending node (in radians)</p>
</dd>
<dt>ap<span class="classifier">float</span></dt><dd><p>satellite argument of periapsis (in radians)</p>
</dd>
</dl>
<dl class="simple">
<dt>rm_GEI2OE<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>perifocal frame to GEI matrix</p>
</dd>
</dl>
<p>R = gei_to_oe(sat_raan, sat_inc, sat_ap)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.icrf2itrf">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">icrf2itrf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inst_GEI</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_to_files</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.icrf2itrf" title="Permalink to this definition"></a></dt>
<dd><p>Function to transform the GEI look direction to ITRF.</p>
<p>Uses Python wrappers for the Standards of Fundamental Astronomy library
<a class="reference external" href="https://www.iausofa.org/">https://www.iausofa.org/</a></p>
<dl class="simple">
<dt>inst_GEI<span class="classifier">TYPE</span></dt><dd><p>DESCRIPTION.</p>
</dd>
<dt>path_to_files<span class="classifier">str</span></dt><dd><p>IES and EOP file path.</p>
</dd>
<dt>time_array<span class="classifier">datetime.datetime</span></dt><dd><p>time array.</p>
</dd>
</dl>
<dl class="simple">
<dt>inst_ITRF<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>instrument look direction in ITRF.</p>
</dd>
</dl>
<dl class="simple">
<dt>inst_ITRF = icrf2itrf(inst_GEI, path_to_files, time_array, </dt><dd><p>GEOx, GEOy, GEOz)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.icrf_to_itrf_rm">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">icrf_to_itrf_rm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_to_files</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_time</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.icrf_to_itrf_rm" title="Permalink to this definition"></a></dt>
<dd><p>Function to calculate ICRF to ITRF matrix using pysofa routines.</p>
<dl class="simple">
<dt>path_to_files<span class="classifier">str</span></dt><dd><p>path_to_initialization files (IERS and EOP).</p>
</dd>
<dt>input_time<span class="classifier">datetime.datetime</span></dt><dd><p>time.</p>
</dd>
</dl>
<dl class="simple">
<dt>rm_ICRF2ITRF<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>ICRF to ITRF rotation matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.itrf_to_icrf_rm">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">itrf_to_icrf_rm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_to_files</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.itrf_to_icrf_rm" title="Permalink to this definition"></a></dt>
<dd><p>Function to calculate ITRF to ICRF rotation matrix using pysofa routines.</p>
<p>Uses the transpose of ITRF to ICRF rotation matrix.</p>
<dl class="simple">
<dt>path_to_files<span class="classifier">str</span></dt><dd><p>path_to_initialization files (IERS and EOP).</p>
</dd>
<dt>time_array<span class="classifier">datetime.datetime</span></dt><dd><p>time array.</p>
</dd>
</dl>
<dl class="simple">
<dt>rm_ICRF2ITRF<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>ICRF to ITRF rotation matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.j2k_to_orf_rm">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">j2k_to_orf_rm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pX</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pY</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pZ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vz</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.j2k_to_orf_rm" title="Permalink to this definition"></a></dt>
<dd><p>Given 6 floats of the J2K/ICRF position and velocity data,
Returns a 3x3 rotation matrix describing the rotation of J2K-&gt; ORF.</p>
<p>Uses the transpose of rNadir_to_J2K.</p>
<p>Ref: 
Canuto, E., Novara, C., Carlucci, D., Montenegro, C. P., &amp; Massotti, L. 
(2018). Orbital Control and Prediction Problems. In Spacecraft Dynamics 
and Control: The Embedded Model Control Approach. Butterworth-Heinemann.</p>
<dl class="simple">
<dt>pX<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>X position in GEIJ2K (km)</p>
</dd>
<dt>pY<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Y position in GEIJ2K (km)</p>
</dd>
<dt>pZ<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Z position in GEIJ2K (km)</p>
</dd>
<dt>Vx<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>X component of velocity in GEIJ2K (km/s)</p>
</dd>
<dt>Vy<span class="classifier">Tnumpy.ndarray[float]</span></dt><dd><p>Y component of velocity in GEIJ2K (km/s)</p>
</dd>
<dt>Vz<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Z component of velocity in GEIJ2K (km/s)</p>
</dd>
</dl>
<dl class="simple">
<dt>rJ2K_to_Nadir<span class="classifier">np.ndarray[float]</span></dt><dd><p>rotation matrice for the transformation from GEIJ2K to ORF</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.nec2terrestrial">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">nec2terrestrial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inst_NEC</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gX</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gY</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gZ</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.nec2terrestrial" title="Permalink to this definition"></a></dt>
<dd><p>Function to transform instrument look direction from NEC to terrestrial 
frame. Uses the transpose of ITRF to NEC rotation matrix.</p>
<dl class="simple">
<dt>inst_NEC<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Instrument look direction in NEC.</p>
</dd>
<dt>gX<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>X position in GEO/ITRF (km)</p>
</dd>
<dt>gY<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Y position in GEO/ITRF (km)</p>
</dd>
<dt>gZ<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Z position in GEO/ITRF (km)</p>
</dd>
</dl>
<dl class="simple">
<dt>inst_ter<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Instrument look direction in ITRF.</p>
</dd>
</dl>
<p>inst_ITRF = nec2itrf(inst_NEC, GEOx, GEOy, GEOz)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.nec_to_terrestrial_rm">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">nec_to_terrestrial_rm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gX</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gY</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gZ</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.nec_to_terrestrial_rm" title="Permalink to this definition"></a></dt>
<dd><p>Function to calculate NEC to ITRF rotation matrix.</p>
<p>Uses the transpose of ITRF to NEC rotation matrix.</p>
<dl class="simple">
<dt>gX<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>X position in GEO/ITRF (km)</p>
</dd>
<dt>gY<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Y position in GEO/ITRF (km)</p>
</dd>
<dt>gZ<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Z position in GEO/ITRF (km)</p>
</dd>
</dl>
<dl class="simple">
<dt>rm_nec2ter<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>3d rotation matrix describing the rotation from NEC to ITRF</p>
</dd>
</dl>
<p>r_nec2ter = nec_to_terrestrial_rm(GEOx, GEOy, GEOz)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.ned2enu">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">ned2enu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inst_NED</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.ned2enu" title="Permalink to this definition"></a></dt>
<dd><p>function for NED to ENU transformations</p>
<p>The transformation matrice from NED to ENU and ENU to NED are the same.
[0 1 0 ; 1 0 0 , 0 0 -1]
in ENU, z increases in upward direction.</p>
<p>Ref: Grewal, M. S., Weill, L. R., &amp; Andrews, A. P. (2008).
Appendix C: Coordinate Transformations. In Global Positioning Systems,
Inertial Navigation, and Integration (pp. 456–501). John Wiley &amp; Sons, Inc.
<a class="reference external" href="https://doi.org/10.1002/9780470099728.app3">https://doi.org/10.1002/9780470099728.app3</a></p>
<dl class="simple">
<dt>inst_NED<span class="classifier">np.ndarray[float]</span></dt><dd><p>instrument look direction in NED</p>
</dd>
</dl>
<dl class="simple">
<dt>inst_ENU<span class="classifier">np.ndarray[float]</span></dt><dd><p>instrument look direction in ENU</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.ned_to_terrestrial_rm">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">ned_to_terrestrial_rm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.ned_to_terrestrial_rm" title="Permalink to this definition"></a></dt>
<dd><p>Function to calculate NED to ECEF rotation matrix.</p>
<p>Uses the transpose of ECEF to NED rotation matrix.</p>
<dl class="simple">
<dt>lat<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Geodetic latitude in degrees</p>
</dd>
<dt>lon<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Geodetic longitude in degrees</p>
</dd>
</dl>
<dl class="simple">
<dt>rm_ned2ter<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Rotation matrix for transformations from NED to ECEF.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.oe_to_gei_rm">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">oe_to_gei_rm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ap</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.oe_to_gei_rm" title="Permalink to this definition"></a></dt>
<dd><p>Function to calculate the perifocal frame (OE) to GEI rotation matrix</p>
<p>To transform from OE to J2K using orbital elements:
RZ_r2i(raan) &#64; RX_r2i(inc) &#64; RZ_r2i(ap)</p>
<p>Ref: Frame rotations and quaternions, Pedro A. Capó-Lugo, Peter M. Bainum,
in Orbital Mechanics and Formation Flying, 2011</p>
<dl class="simple">
<dt>inc<span class="classifier">float</span></dt><dd><p>satellite inclination (in radians).</p>
</dd>
<dt>raan<span class="classifier">float</span></dt><dd><p>satellite right ascension of ascending node (in radians)</p>
</dd>
<dt>ap<span class="classifier">float</span></dt><dd><p>satellite argument of periapsis (in radians)</p>
</dd>
</dl>
<dl class="simple">
<dt>rm_OE2GEI<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>perifocal frame to GEI matrix</p>
</dd>
</dl>
<p>R = oe_to_gei(sat_raan, sat_inc, sat_ap)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.orf_to_j2k_rm">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">orf_to_j2k_rm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pX</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pY</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pZ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vz</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.orf_to_j2k_rm" title="Permalink to this definition"></a></dt>
<dd><p>Given 6 floats of the J2K/ICRF position and velocity data,
Returns a 3x3 rotation matrix describing the rotation of ORF -&gt; J2K.</p>
<p>Ref: 
Canuto, E., Novara, C., Carlucci, D., Montenegro, C. P., &amp; Massotti, L. 
(2018). Orbital Control and Prediction Problems. In Spacecraft Dynamics 
and Control: The Embedded Model Control Approach. Butterworth-Heinemann.</p>
<dl class="simple">
<dt>pX<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>X position in GEIJ2K (km)</p>
</dd>
<dt>pY<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Y position in GEIJ2K (km)</p>
</dd>
<dt>pZ<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Z position in GEIJ2K (km)</p>
</dd>
<dt>Vx<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>X component of velocity in GEIJ2K (km/s)</p>
</dd>
<dt>Vy<span class="classifier">Tnumpy.ndarray[float]</span></dt><dd><p>Y component of velocity in GEIJ2K (km/s)</p>
</dd>
<dt>Vz<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Z component of velocity in GEIJ2K (km/s)</p>
</dd>
</dl>
<dl class="simple">
<dt>rNadir_to_J2K<span class="classifier">np.ndarray[float]</span></dt><dd><p>rotation matrice for the transformation from ORF to GEIJ2K</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.orf_to_j2k_use_orbital_elements">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">orf_to_j2k_use_orbital_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">body_vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pX</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pY</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pZ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([[0,</span> <span class="pre">0,</span> <span class="pre">-</span> <span class="pre">1],</span> <span class="pre">[1,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[0,</span> <span class="pre">-</span> <span class="pre">1,</span> <span class="pre">0]])</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.orf_to_j2k_use_orbital_elements" title="Permalink to this definition"></a></dt>
<dd><p>Employs orbital elements to transform from ORF to GEIJ2K:</p>
<p>To align the perifocal frame with the orbital frame 
RZ_r2i(TA) &#64; P &#64;  body_vec</p>
<p>Ref:Canuto, E., Novara, C., Carlucci, D., Montenegro, C. P., &amp; Massotti, L. 
(2018). Orbital Control and Prediction Problems. In Spacecraft Dynamics 
and Control: The Embedded Model Control Approach. Butterworth-Heinemann</p>
<dl class="simple">
<dt>body_vec<span class="classifier">np.ndarray[float]</span></dt><dd><p>rotated body frame vectors</p>
</dd>
<dt>pX<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>X position in GEIJ2K (km)</p>
</dd>
<dt>pY<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Y position in GEIJ2K (km)</p>
</dd>
<dt>pZ<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Z position in GEIJ2K (km)</p>
</dd>
<dt>Vx<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>X component of velocity in GEIJ2K (km/s)</p>
</dd>
<dt>Vy<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Y component of velocity in GEIJ2K (km/s)</p>
</dd>
<dt>Vz<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Z component of velocity in GEIJ2K (km/s)</p>
</dd>
<dt>P<span class="classifier">numpy.ndarray</span></dt><dd><p>optional reordering matrix to align the perifocal frame with the</p>
</dd>
</dl>
<p>orbital frame. Default is P= np.array([[0, 0, -1],[1, 0, 0],[0,-1,0]])</p>
<dl class="simple">
<dt>inst_GEI<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>instrument look direction in GEIJ2K</p>
</dd>
</dl>
<p>inst_GEI =         orf_to_j2k_use_orbital_elements(body_vec, pX, pY, pZ, Vx, Vy, Vz)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.orf_to_j2k_use_spacecraft_ephemeris">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">orf_to_j2k_use_spacecraft_ephemeris</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">body_vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pX</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pY</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pZ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vz</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.orf_to_j2k_use_spacecraft_ephemeris" title="Permalink to this definition"></a></dt>
<dd><p>Employs spacecraft ephemeris to transform from ORF to GEIJ2K:</p>
<dl class="simple">
<dt>body_vec<span class="classifier">np.ndarray[float]</span></dt><dd><p>rotated body frame vectors</p>
</dd>
<dt>pX<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>X position in GEIJ2K (km)</p>
</dd>
<dt>pY<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Y position in GEIJ2K (km)</p>
</dd>
<dt>pZ<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Z position in GEIJ2K (km)</p>
</dd>
<dt>Vx<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>X component of velocity in GEIJ2K (km/s)</p>
</dd>
<dt>Vy<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Y component of velocity in GEIJ2K (km/s)</p>
</dd>
<dt>Vz<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Z component of velocity in GEIJ2K (km/s)</p>
</dd>
<dt>P<span class="classifier">numpy.ndarray</span></dt><dd><p>optional reordering matrix to align the perifocal frame with the</p>
</dd>
</dl>
<p>orbital frame. Default is P= np.array([[0, 0, -1],[1, 0, 0],[0,-1,0]])</p>
<dl class="simple">
<dt>inst_GEI<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>instrument look direction in GEIJ2K</p>
</dd>
</dl>
<p>inst_GEI =         orf_to_j2k_use_spacecraft_ephemeris(body_vec, pX, pY, pZ, Vx, Vy, Vz)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.terrestrial2nec">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">terrestrial2nec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inst_ter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gX</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gY</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gZ</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.terrestrial2nec" title="Permalink to this definition"></a></dt>
<dd><p>Function to transform instrument look direction from terrestrial frame
to NEC. Uses (Nielsen, 2019) method.</p>
<dl class="simple">
<dt>inst_ter<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Instrument look direction in terrestrial frame.</p>
</dd>
<dt>gX<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>X position in GEO/ITRF (km)</p>
</dd>
<dt>gY<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Y position in GEO/ITRF (km)</p>
</dd>
<dt>gZ<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Z position in GEO/ITRF (km)</p>
</dd>
</dl>
<dl class="simple">
<dt>inst_NEC<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>instrument look direction in NEC.</p>
</dd>
</dl>
<p>inst_NEC = itrf2nec(inst_ITRF, GEOx, GEOy, GEOz)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.terrestrial2ned">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">terrestrial2ned</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inst_ter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.terrestrial2ned" title="Permalink to this definition"></a></dt>
<dd><p>function for transformations from ECEF to NED (z is positive downwards)</p>
<dl class="simple">
<dt>inst_ter<span class="classifier">np.ndarray[float]</span></dt><dd><p>instrument look direction in terrestrial frame</p>
</dd>
<dt>lat<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Geodetic latitude in degrees</p>
</dd>
<dt>lon<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Geodetic longitude in degrees</p>
</dd>
</dl>
<dl class="simple">
<dt>inst_NED<span class="classifier">np.ndarray[float]</span></dt><dd><p>instrument look direction in NED</p>
</dd>
</dl>
<p>inst_NED = terrestrial2ned(inst_ter, lat, lon)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.terrestrial_to_nec_rm">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">terrestrial_to_nec_rm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gX</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gY</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gZ</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.terrestrial_to_nec_rm" title="Permalink to this definition"></a></dt>
<dd><p>Given the Geographic Cartesian Position ephemeris data return a 
3d rotation matrix describing the rotation from ITRF to NEC</p>
<p>Ref:
<a class="reference external" href="https://earth.esa.int/documents/10174/1514862/Swarm_Level-1b_Processor_Algorithms">https://earth.esa.int/documents/10174/1514862/Swarm_Level-1b_Processor_Algorithms</a>
Page 137, “C.3 North East Center (NEC)</p>
<dl class="simple">
<dt>gX<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>X position in GEO/ITRF (km)</p>
</dd>
<dt>gY<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Y position in GEO/ITRF (km)</p>
</dd>
<dt>gZ<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Z position in GEO/ITRF (km)</p>
</dd>
</dl>
<dl class="simple">
<dt>R_NEC<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>3d rotation matrix describing the rotation from ITRF to NEC</p>
</dd>
</dl>
<p>rter2nec  = terrestrial_to_nec_rm(GEOx, GEOy, GEOz)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="use_rotation_matrices.terrestrial_to_ned_rm">
<span class="sig-prename descclassname"><span class="pre">use_rotation_matrices.</span></span><span class="sig-name descname"><span class="pre">terrestrial_to_ned_rm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#use_rotation_matrices.terrestrial_to_ned_rm" title="Permalink to this definition"></a></dt>
<dd><p>Function to calculate the ECEF to NED rotation matrix.</p>
<p>Y-Z (pitch-yaw) sequence with longitude and latitude are needed.
1. Aligning the x-y plane of ECEF and NED using longitude: yaw(longitude)
2. Aligning the x-z plane using latitude: pitch(-(pi/2+latitude))</p>
<p>Ref: 
1. J. Riggs, Coordinate transformations via Euler Angle Rotations,
Rev. E - 10 April 2019
2. Cai, G., Chen, B.M., Lee, T.H. (2011). Coordinate Systems and
Transformations. In: Unmanned Rotorcraft Systems. Advances in Industrial
Control. Springer, London. <a class="reference external" href="https://doi.org/10.1007/978-0-85729-635-1_2">https://doi.org/10.1007/978-0-85729-635-1_2</a></p>
<dl class="simple">
<dt>lat<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Geodetic latitude in degrees</p>
</dd>
<dt>lon<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Geodetic longitude in degrees</p>
</dd>
</dl>
<dl class="simple">
<dt>rm_ter2ned<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Rotation matrix for transformations from ECEF to NED.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-attitude_analysis">
<span id="attitude-analysis-module-to-obtain-instrument-pointing-direction-in-nec-and-ned"></span><h1>attitude_analysis: Module to obtain instrument pointing direction in NEC and NED<a class="headerlink" href="#module-attitude_analysis" title="Permalink to this heading"></a></h1>
<p>attitude_analysis module includes functions for finding the instrument
pointing direction in spacecraft orbital frame(ORF), GEI J2000, ECEF, ITRF,</p>
<blockquote>
<div><p>NEC, NED and ENU.</p>
</div></blockquote>
<p>Additional functions are available to calculate the look angles of the
spacecraft and the instrument with respect to a ground point, line-of-sight
look direction vector from the ground point to the spacecraft and the distance
between spacecraft and the ground point. Slew quality can be calculated given
the threshold for the angle between the LOS direction and the
instrument pointing.</p>
<p>&#64;author: ceren</p>
<dl class="py function">
<dt class="sig sig-object py" id="attitude_analysis.LA_inst">
<span class="sig-prename descclassname"><span class="pre">attitude_analysis.</span></span><span class="sig-name descname"><span class="pre">LA_inst</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pLon</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#attitude_analysis.LA_inst" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>vec<span class="classifier">Array of float</span></dt><dd><p>Boresight pointing vector.</p>
</dd>
<dt>e<span class="classifier">int</span></dt><dd><p>Column of the east vector in vec.</p>
</dd>
<dt>n<span class="classifier">int</span></dt><dd><p>Column of the north vector in vec.</p>
</dd>
<dt>lon<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft longitude (degrees).</p>
</dd>
<dt>lat<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft latitude (degrees).</p>
</dd>
<dt>pLon<span class="classifier">float</span></dt><dd><p>Longitude of the target on the ground (degrees).</p>
</dd>
</dl>
<dl>
<dt>dict<span class="classifier">dict</span></dt><dd><p>Look angles of the instrument: azimuth and depression. 
vec_azim: Array of float</p>
<blockquote>
<div><p>Look angle of the instrument in horizontal plane (degrees)</p>
</div></blockquote>
<dl class="simple">
<dt>vec_dep: Array of float</dt><dd><p>Depression angle of the instrument (degrees)</p>
</dd>
</dl>
</dd>
</dl>
<p>inst_look_angles = LA_rri(RRI_enu, 0, 1, Lon, Lat)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="attitude_analysis.LA_sat">
<span class="sig-prename descclassname"><span class="pre">attitude_analysis.</span></span><span class="sig-name descname"><span class="pre">LA_sat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">palt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">salt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#attitude_analysis.LA_sat" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the satellite look angle: elevation and azimuth angle that is 
needed for the satellite to look towards a point in GEO frame.</p>
<dl class="simple">
<dt>Ref: ASD5: Earth Station Look Angles By Prof. Gregory D. Durgin,</dt><dd><p>Astrodynamics, Georgia Tech, 2009.</p>
</dd>
</dl>
<dl class="simple">
<dt>plon<span class="classifier">float</span></dt><dd><p>Longitude of the target on the ground (degrees).</p>
</dd>
<dt>plat<span class="classifier">float</span></dt><dd><p>Latitude of the target on the ground (degrees).</p>
</dd>
<dt>palt<span class="classifier">float</span></dt><dd><p>altitude of the point in GEO frame (km).</p>
</dd>
<dt>slon<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft longitude (degrees).</p>
</dd>
<dt>slat<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft latitude (degrees).</p>
</dd>
<dt>salt<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>altitude of satellite in GEO frame (km).</p>
</dd>
</dl>
<dl>
<dt>dict<span class="classifier">dict</span></dt><dd><p>Look angles of the spacecraft: azimuth and elevation.
azimuth: numpy.ndarray[float]</p>
<blockquote>
<div><p>Satellite location in terms of azimuth (degrees).</p>
</div></blockquote>
<dl class="simple">
<dt>elevation: numpy.ndarray[float]</dt><dd><p>Elevation angle of the spacecraft (degrees).</p>
</dd>
</dl>
</dd>
</dl>
<p>sat_look_angles = LA_sat(plon, plat,  palt, slon, slat, salt)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="attitude_analysis.calculate_los_vec">
<span class="sig-prename descclassname"><span class="pre">attitude_analysis.</span></span><span class="sig-name descname"><span class="pre">calculate_los_vec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pLon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pLat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pAlt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">salt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#attitude_analysis.calculate_los_vec" title="Permalink to this definition"></a></dt>
<dd><p>calculates line-of-sight vector from a point to the spacecraft location
using the geopy.dist.geodesic</p>
<dl class="simple">
<dt>plon<span class="classifier">float</span></dt><dd><p>Longitude of the target on the ground (degrees).</p>
</dd>
<dt>plat<span class="classifier">float</span></dt><dd><p>Latitude of the target on the ground (degrees).</p>
</dd>
<dt>palt<span class="classifier">float</span></dt><dd><p>altitude of the point in GEO frame (km).</p>
</dd>
<dt>slon<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft longitude (degrees).</p>
</dd>
<dt>slat<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft latitude (degrees).</p>
</dd>
<dt>salt<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>altitude of satellite in GEO frame (km).</p>
</dd>
</dl>
<dl class="simple">
<dt>los_enu_arr<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>line-of-sight vector from the point to the spacecraft in ENU system.</p>
</dd>
<dt>los_ned_arr<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>line-of-sight vector from the point to the spacecraft in NED system.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="attitude_analysis.calculate_reception_angle">
<span class="sig-prename descclassname"><span class="pre">attitude_analysis.</span></span><span class="sig-name descname"><span class="pre">calculate_reception_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inst_ned</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pLat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pLon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pAlt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inst</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'boresight'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#attitude_analysis.calculate_reception_angle" title="Permalink to this definition"></a></dt>
<dd><p>function to calculate the reception angle of an instrument.
reception angle: angle between the instrument look direction vector and 
the line-of-sight vector from the target</p>
<dl class="simple">
<dt>inst_ned<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>instrument look direction vector in North-East-Down.</p>
</dd>
<dt>pLat<span class="classifier">float</span></dt><dd><p>geodetic latitude of the target (degrees).</p>
</dd>
<dt>pLon<span class="classifier">float</span></dt><dd><p>geodetic longitude of the target (degrees).</p>
</dd>
<dt>pAlt<span class="classifier">float</span></dt><dd><p>Altitude of the target (km).</p>
</dd>
<dt>lat<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft position in geodetic latitude (degrees).</p>
</dd>
<dt>lon<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft position in geodetic latitude(degrees).</p>
</dd>
<dt>alt<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft altitude (km).</p>
</dd>
<dt>inst<span class="classifier">str, optional</span></dt><dd><p>cra is calculated as (90-ra) for dipoles, (180-ra) for boresight. 
input can be boresight or dipole. The default is ‘boresight’.</p>
</dd>
</dl>
<dl class="simple">
<dt>ra_los<span class="classifier">numpy.ndarray(float)</span></dt><dd><p>reception angle of the instrument (degrees).</p>
</dd>
<dt>cra_los<span class="classifier">numpy.ndarray(float)</span></dt><dd><p>complementary reception angle of the instrument (degrees).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="attitude_analysis.find_instrument_attitude">
<span class="sig-prename descclassname"><span class="pre">attitude_analysis.</span></span><span class="sig-name descname"><span class="pre">find_instrument_attitude</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rotated_body</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geiX</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geiY</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geiZ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geiVx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geiVy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geiVz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geoX</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geoY</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geoZ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_to_files</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ephemeris'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'itrf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame3</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nec'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#attitude_analysis.find_instrument_attitude" title="Permalink to this definition"></a></dt>
<dd><p>Takes in the rotated body vector in orbital frame and outputs instrument
look direction in NEC or NED coordinate systems by utilizing the functions
in use_rotation_matrices module.</p>
<dl class="simple">
<dt>rotated_body<span class="classifier">TYPE</span></dt><dd><p>DESCRIPTION.</p>
</dd>
<dt>geiX<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>X position in GEIJ2K (km).</p>
</dd>
<dt>geiY<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Y position in GEIJ2K (km).</p>
</dd>
<dt>geiZ<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Z position in GEIJ2K (km).</p>
</dd>
<dt>geiVx<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>X component of velocity in GEIJ2K (km/s).</p>
</dd>
<dt>geiVy<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Y component of velocity in GEIJ2K (km/s).</p>
</dd>
<dt>geiVz<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Z component of velocity in GEIJ2K (km/s).</p>
</dd>
<dt>geoX<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>X position in GEO (km).</p>
</dd>
<dt>geoY<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Y position in GEO (km).</p>
</dd>
<dt>geoZ<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Z position in GEO (km).</p>
</dd>
<dt>time_array<span class="classifier">datetime.datetime</span></dt><dd><p>time.</p>
</dd>
<dt>start_date<span class="classifier">datetime.datetime</span></dt><dd><p>start of the experiment.</p>
</dd>
<dt>lat<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Geodetic latitude in degrees.</p>
</dd>
<dt>lon<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Geodetic longitude in degrees.</p>
</dd>
<dt>path_to_files<span class="classifier">str</span></dt><dd><p>path_to_initialization files (IERS and EOP).</p>
</dd>
<dt>method1<span class="classifier">str, optional</span></dt><dd><p>Transformation method to ICRF/GEI J2K.
Can be ephemeris or orbital_elements. The default is ‘ephemeris’.</p>
</dd>
<dt>frame2<span class="classifier">str, optional</span></dt><dd><p>Terrestrial frame: ECEF or ITRF. The default is ‘itrf’.</p>
</dd>
<dt>frame3<span class="classifier">str, optional</span></dt><dd><p>Final coordinate system: NEC or NED. The default is ‘nec’.</p>
</dd>
</dl>
<dl class="simple">
<dt>inst_geo<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>instrument look direction in the requested coordinate system:NEC or NED</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="attitude_analysis.find_slew_inst">
<span class="sig-prename descclassname"><span class="pre">attitude_analysis.</span></span><span class="sig-name descname"><span class="pre">find_slew_inst</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ra_los</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">criteria</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#attitude_analysis.find_slew_inst" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>function to classify slew according to the given criteria</dt><dd><p>1 : Front face slew
0: no dipoles slewed
-1: Back face slew</p>
</dd>
</dl>
<dl class="simple">
<dt>ra_los<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Boresight reception angle (degrees).</p>
</dd>
<dt>criteria<span class="classifier">float</span></dt><dd><p>criteria/threshold for slew (degrees).</p>
</dd>
</dl>
<dl class="simple">
<dt>slew<span class="classifier">int</span></dt><dd><p>Classification of slew according to the given criteria</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="attitude_analysis.find_slew_rri">
<span class="sig-prename descclassname"><span class="pre">attitude_analysis.</span></span><span class="sig-name descname"><span class="pre">find_slew_rri</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ra_los</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ra_D1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ra_D2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">criteria</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#attitude_analysis.find_slew_rri" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>function to classify slew according to the given criteria</dt><dd><p>2: Front face slew 
1: 1 dipole back, 1 dipole front, boresight front slew
0.5 : 1 dipole front slew
0: no dipoles slewed
-0.5: 1 dipole back slew
-1: 1 dipole back, 1 dipole front, boresight back slew
-2: Back face slew</p>
</dd>
</dl>
<dl class="simple">
<dt>ra_los<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Boresight reception angle (degrees).</p>
</dd>
<dt>ra_D1<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Dipole1 reception angle (degrees).</p>
</dd>
<dt>ra_D2<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Dipole2 reception angle (degrees).</p>
</dd>
<dt>criteria<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>criteria/threshold for slew (degrees).</p>
</dd>
</dl>
<dl class="simple">
<dt>slew<span class="classifier">int</span></dt><dd><p>Classification of slew according to the given criteria</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="attitude_analysis.rotate_rri">
<span class="sig-prename descclassname"><span class="pre">attitude_analysis.</span></span><span class="sig-name descname"><span class="pre">rotate_rri</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">body_vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Roll</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pitch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Yaw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#attitude_analysis.rotate_rri" title="Permalink to this definition"></a></dt>
<dd><p>Rotation of body vectors in orbital frame (ORF) of Swarm-E
using roll, pitch, and yaw angles.</p>
<p>The rotation sequence is X-&gt;Y-&gt;Z; roll-&gt;pitch-&gt;yaw according to the RRI
data description.</p>
<p>Ref: University of Calgary, e-POP Radio Receiver Instrument (RRI)
User’s Manual, Doc. no. ePOP-5024, Rev. D (2018)</p>
<p><a class="reference external" href="https://epop.phys.ucalgary.ca/data-handbook/coordinate-systems/">https://epop.phys.ucalgary.ca/data-handbook/coordinate-systems/</a></p>
<dl class="simple">
<dt>body_vec<span class="classifier">tuple</span></dt><dd><p>x, y, z : initial position vectors for antenna in ORF</p>
</dd>
<dt>Roll<span class="classifier">float</span></dt><dd><p>roll angle in degrees</p>
</dd>
<dt>Pitch<span class="classifier">float</span></dt><dd><p>pitch angle in degrees</p>
</dd>
<dt>Yaw<span class="classifier">float</span></dt><dd><p>yaw angle in degrees</p>
</dd>
</dl>
<dl class="simple">
<dt>rotated_body<span class="classifier">numpy.ndarray</span></dt><dd><p>rotated body vectors of RRI in ORF</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="attitude_analysis.spacecraft_distance_from_a_point">
<span class="sig-prename descclassname"><span class="pre">attitude_analysis.</span></span><span class="sig-name descname"><span class="pre">spacecraft_distance_from_a_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pLon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pLat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pAlt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">salt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#attitude_analysis.spacecraft_distance_from_a_point" title="Permalink to this definition"></a></dt>
<dd><p>calculates spacecraft distance from a point using the 
geopy.dist.geodesic</p>
<dl class="simple">
<dt>plon<span class="classifier">float</span></dt><dd><p>Longitude of the target on the ground (degrees).</p>
</dd>
<dt>plat<span class="classifier">float</span></dt><dd><p>Latitude of the target on the ground (degrees).</p>
</dd>
<dt>palt<span class="classifier">float</span></dt><dd><p>altitude of the point in GEO frame (km).</p>
</dd>
<dt>slon<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft longitude (degrees).</p>
</dd>
<dt>slat<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft latitude (degrees).</p>
</dd>
<dt>salt<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>altitude of satellite in GEO frame (km).</p>
</dd>
</dl>
<dl class="simple">
<dt>distance<span class="classifier">np.ndarray[float]</span></dt><dd><p>slant range between the ground point and spacecraft (km).</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-attitude_plotter">
<span id="attitude-plotter-module-to-visualize-satellite-instrument-pointing-direction"></span><h1>attitude_plotter: Module to visualize satellite instrument pointing direction<a class="headerlink" href="#module-attitude_plotter" title="Permalink to this heading"></a></h1>
<p>Plotting routines for 2D and 3D look directions of the instrument onboard 
spacecraft.</p>
<p>&#64;author: ceren</p>
<dl class="py class">
<dt class="sig sig-object py" id="attitude_plotter.MyAxes3D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">attitude_plotter.</span></span><span class="sig-name descname"><span class="pre">MyAxes3D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">baseObject</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sides_to_draw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#attitude_plotter.MyAxes3D" title="Permalink to this definition"></a></dt>
<dd><p>Class to draw 3D grids for the counter-clockwise angles of 3D plots.</p>
<dl class="py method">
<dt class="sig sig-object py" id="attitude_plotter.MyAxes3D.draw">
<span class="sig-name descname"><span class="pre">draw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">renderer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#attitude_plotter.MyAxes3D.draw" title="Permalink to this definition"></a></dt>
<dd><p>Draw the Artist (and its children) using the given renderer.</p>
<p>This has no effect if the artist is not visible (<cite>.Artist.get_visible</cite>
returns False).</p>
<p>renderer : <cite>.RendererBase</cite> subclass.</p>
<p>This method is overridden in the Artist subclasses.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="attitude_plotter.MyAxes3D.set">
<span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adjustable=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">agg_filter=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anchor=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">animated=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aspect=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">autoscale_on=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">autoscalex_on=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">autoscaley_on=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">autoscalez_on=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes_locator=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axisbelow=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">box_aspect=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip_box=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip_on=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip_path=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">facecolor=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_on=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gid=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_layout=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mouseover=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">navigate=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_effects=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">picker=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">position=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proj_type=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prop_cycle=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rasterization_zorder=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rasterized=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sketch_params=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snap=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">some_features_visibility=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subplotspec=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">url=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">visible=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xbound=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlabel=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlim=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlim3d=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xmargin=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xscale=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xticklabels=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xticks=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ybound=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylabel=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylim=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylim3d=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ymargin=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yscale=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yticklabels=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yticks=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zbound=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zlabel=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zlim=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zmargin=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zorder=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zscale=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zticklabels=&lt;UNSET&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zticks=&lt;UNSET&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#attitude_plotter.MyAxes3D.set" title="Permalink to this definition"></a></dt>
<dd><p>Set multiple properties at once.</p>
<p>Supported properties are</p>
<dl class="simple">
<dt>Properties:</dt><dd><p>adjustable: {‘box’, ‘datalim’}
agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array and two offsets from the bottom left corner of the image
alpha: scalar or None
anchor: (float, float) or {‘C’, ‘SW’, ‘S’, ‘SE’, ‘E’, ‘NE’, …}
animated: bool
aspect: {‘auto’, ‘equal’, ‘equalxy’, ‘equalxz’, ‘equalyz’}
autoscale_on: bool
autoscalex_on: unknown
autoscaley_on: unknown
autoscalez_on: unknown
axes_locator: Callable[[Axes, Renderer], Bbox]
axisbelow: bool or ‘line’
box_aspect: 3-tuple of floats or None
clip_box: <cite>.Bbox</cite>
clip_on: bool
clip_path: Patch or (Path, Transform) or None
facecolor or fc: color
figure: <cite>.Figure</cite>
frame_on: bool
gid: str
in_layout: bool
label: object
mouseover: bool
navigate: bool
navigate_mode: unknown
path_effects: <cite>.AbstractPathEffect</cite>
picker: None or bool or float or callable
position: [left, bottom, width, height] or <cite>~matplotlib.transforms.Bbox</cite>
proj_type: {‘persp’, ‘ortho’}
prop_cycle: unknown
rasterization_zorder: float or None
rasterized: bool
sketch_params: (scale: float, length: float, randomness: float)
snap: bool or None
some_features_visibility: unknown
subplotspec: unknown
title: str
transform: <cite>.Transform</cite>
url: str
visible: bool
xbound: unknown
xlabel: str
xlim or xlim3d: (bottom: float, top: float)
xlim3d: (bottom: float, top: float)
xmargin: float greater than -0.5
xscale: unknown
xticklabels: unknown
xticks: unknown
ybound: unknown
ylabel: str
ylim or ylim3d: (bottom: float, top: float)
ylim3d: (bottom: float, top: float)
ymargin: float greater than -0.5
yscale: unknown
yticklabels: unknown
yticks: unknown
zbound: unknown
zlabel: unknown
zlim or zlim3d: unknown
zmargin: float greater than -0.5
zorder: float
zscale: unknown
zticklabels: unknown
zticks: unknown</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="attitude_plotter.attitude_2d_altitude">
<span class="sig-prename descclassname"><span class="pre">attitude_plotter.</span></span><span class="sig-name descname"><span class="pre">attitude_2d_altitude</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Px</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inst_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'lon'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">60</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#attitude_plotter.attitude_2d_altitude" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>time_array<span class="classifier">datetime.datetime</span></dt><dd><p>experiment time interval as datetime array.</p>
</dd>
<dt>extent<span class="classifier">list</span></dt><dd><p>extent = [Lonmin, Lonmax, Altmin, Altmax].</p>
</dd>
<dt>x<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft longitude(degrees).</p>
</dd>
<dt>y<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft latitude (degrees).</p>
</dd>
<dt>z<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft altitude (km).</p>
</dd>
<dt>Px<span class="classifier">float</span></dt><dd><p>Location of the target on the x_axis (lat or lon) (degrees).</p>
</dd>
<dt>V<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>vectors to be plotted (need to be in ENU coordinate system).</p>
</dd>
<dt>inst_name<span class="classifier">str</span></dt><dd><p>Instrument name for labels.</p>
</dd>
<dt>target_name<span class="classifier">str</span></dt><dd><p>Target name for labels.</p>
</dd>
<dt>x_axis<span class="classifier">str, optional</span></dt><dd><p>Parameter to be plotted on the x-axis (lat or lon). 
The default is ‘lon’.</p>
</dd>
<dt>step<span class="classifier">int</span></dt><dd><p>Time in seconds between pointing direction vectors. The default is 60.</p>
</dd>
</dl>
<dl class="simple">
<dt>fig<span class="classifier">figure.Figure</span></dt><dd><p>Figure object of matplotlib.figure module.</p>
</dd>
<dt>ax<span class="classifier">axes</span></dt><dd><p>Axes object of matplotlib.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="attitude_plotter.attitude_2d_on_map">
<span class="sig-prename descclassname"><span class="pre">attitude_plotter.</span></span><span class="sig-name descname"><span class="pre">attitude_2d_on_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Px</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Py</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inst_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index_ca</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">60</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#attitude_plotter.attitude_2d_on_map" title="Permalink to this definition"></a></dt>
<dd><p>Plots the spacecraft trajectory and instrument pointing direction vectors 
on map.</p>
<dl class="simple">
<dt>time_array<span class="classifier">datetime.datetime</span></dt><dd><p>experiment time interval as datetime array.</p>
</dd>
<dt>extent<span class="classifier">TYPE</span></dt><dd><p>DESCRIPTION.</p>
</dd>
<dt>x<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft longitude(degrees).</p>
</dd>
<dt>y<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft latitude (degrees).</p>
</dd>
<dt>z<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft altitude (km).</p>
</dd>
<dt>Px<span class="classifier">float</span></dt><dd><p>geodetic longitude of the target.</p>
</dd>
<dt>Py<span class="classifier">float</span></dt><dd><p>geodetic latitude of the target.</p>
</dd>
<dt>V<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>vectors to be plotted (need to be in ENU coordinate system).</p>
</dd>
<dt>inst_name<span class="classifier">str</span></dt><dd><p>Instrument name for labels.</p>
</dd>
<dt>target_name<span class="classifier">str</span></dt><dd><p>Target name for labels.</p>
</dd>
<dt>index_ca<span class="classifier">int</span></dt><dd><p>index of the point of closest approach. can be found by using 
miscellaneous.find_index</p>
</dd>
<dt>step<span class="classifier">int</span></dt><dd><p>Time in seconds between pointing direction vectors. The default is 60.</p>
</dd>
</dl>
<dl class="simple">
<dt>fig<span class="classifier">figure.Figure</span></dt><dd><p>Figure object of matplotlib.figure module.</p>
</dd>
<dt>ax<span class="classifier">axes</span></dt><dd><p>Axes object of matplotlib.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="attitude_plotter.attitude_3d_connect_to_subpoint">
<span class="sig-prename descclassname"><span class="pre">attitude_plotter.</span></span><span class="sig-name descname"><span class="pre">attitude_3d_connect_to_subpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">title</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Px</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Py</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">60</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['red',</span> <span class="pre">'#12e193',</span> <span class="pre">'red',</span> <span class="pre">'#12e193',</span> <span class="pre">'black',</span> <span class="pre">'#0165fc']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arrlen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.25,</span> <span class="pre">0.25,</span> <span class="pre">0.25,</span> <span class="pre">0.25,</span> <span class="pre">0.75,</span> <span class="pre">0.75]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['solid',</span> <span class="pre">'solid',</span> <span class="pre">'solid',</span> <span class="pre">'solid',</span> <span class="pre">'solid',</span> <span class="pre">'solid']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['$Dipole_{1}$',</span> <span class="pre">'$Dipole_{2}$',</span> <span class="pre">'Boresight',</span> <span class="pre">'$Ray_{LOS}$']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">markers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['_',</span> <span class="pre">'$--$',</span> <span class="pre">'$\\longrightarrow$',</span> <span class="pre">'$\\longrightarrow$',</span> <span class="pre">'H',</span> <span class="pre">'H']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legend_colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['red',</span> <span class="pre">'#12e193',</span> <span class="pre">'black',</span> <span class="pre">'#0165fc',</span> <span class="pre">'None',</span> <span class="pre">'black']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legend_edgecolors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['red',</span> <span class="pre">'#12e193',</span> <span class="pre">'black',</span> <span class="pre">'#0165fc',</span> <span class="pre">'black',</span> <span class="pre">'black']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'upper</span> <span class="pre">center'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#attitude_plotter.attitude_3d_connect_to_subpoint" title="Permalink to this definition"></a></dt>
<dd><p>Plotting function to show projected look direction of RRI on the ground.
The defaults for the keywords are based on RRI plots.</p>
<dl class="simple">
<dt>title<span class="classifier">str</span></dt><dd><p>plot title.</p>
</dd>
<dt>time_array<span class="classifier">datetime.datetime</span></dt><dd><p>experiment time interval as datetime array.</p>
</dd>
<dt>Px<span class="classifier">float</span></dt><dd><p>geodetic longitude of the target.</p>
</dd>
<dt>Py<span class="classifier">float</span></dt><dd><p>geodetic latitude of the target.</p>
</dd>
<dt>Pz<span class="classifier">float</span></dt><dd><p>altitude of the target.</p>
</dd>
<dt>x<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft longitude.</p>
</dd>
<dt>y<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft latitude.</p>
</dd>
<dt>z<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft altitude.</p>
</dd>
<dt>target_name<span class="classifier">str</span></dt><dd><p>target name.</p>
</dd>
<dt><a href="#id3"><span class="problematic" id="id4">*</span></a>V<span class="classifier">numpy.ndarray</span></dt><dd><p>vectors to be plotted (need to be in ENU coordinate system).
vec_args = M1_enu, M3_enu, M2_enu, M4_enu, RRI_enu, los_enu_arr</p>
</dd>
<dt>step<span class="classifier">float, optional</span></dt><dd><p>Step in seconds to plot vectors. The default is 60.</p>
</dd>
<dt>vc<span class="classifier">list, optional</span></dt><dd><p>vector colors. 
The default is [‘red’,’#12e193’, ‘red’, ‘#12e193’, ‘black’, ‘#0165fc’].</p>
</dd>
<dt>arrlen<span class="classifier">TYPE, optional</span></dt><dd><p>DESCRIPTION. 
The default is [0.25, 0.25, 0.25, 0.25, 0.75, 0.75].</p>
</dd>
<dt>ls<span class="classifier">list, optional</span></dt><dd><p>linestyles for vectors.
The default is [‘solid’, ‘solid’, ‘solid’, ‘solid’,’solid’,  ‘solid’].</p>
</dd>
<dt>labels<span class="classifier">list, optional</span></dt><dd><p>vector labels for legend.
The default is [‘$Dipole_{1}$’,’$Dipole_{2}$’,’Boresight’’$Ray_{LOS}$’].</p>
</dd>
<dt>markers<span class="classifier">list, optional</span></dt><dd><p>legend markers.
The default is [‘_’,’$–$’,r’$longrightarrow$’,                        r’$longrightarrow$’,’H’,’H’].</p>
</dd>
<dt>legend_colors<span class="classifier">list, optional</span></dt><dd><p>colors for labels in the legend. 
The default is [‘red’, ‘#12e193’,’black’,’#0165fc’ ,’None’, ‘black’].</p>
</dd>
<dt>legend_edgecolors<span class="classifier">list, optional</span></dt><dd><p>edgecolors for labels in the legend.
The default is [‘red’, ‘#12e193’,’black’,’#0165fc’ ,’black’, ‘black’].</p>
</dd>
<dt>loc<span class="classifier">str</span></dt><dd><p>legend location. uses same keywords as matplotlib legend.
The default is ‘upper center’.</p>
</dd>
</dl>
<dl class="simple">
<dt>fig<span class="classifier">figure.Figure</span></dt><dd><p>Figure object of matplotlib.figure module.</p>
</dd>
</dl>
<p>V = M1_enu, M3_enu, M2_enu, M4_enu, RRI_enu, los_enu_arr
connect_to_subpoint= ap.attitude_3d_connect_to_subpoint(title, time_array,                                                  pLon, pLat, OH,                                                   Lon, Lat, Alt,</p>
<blockquote>
<div><p>‘Ottawa’, <a href="#id5"><span class="problematic" id="id6">*</span></a>V, step = 60)</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="attitude_plotter.attitude_3d_connect_to_target">
<span class="sig-prename descclassname"><span class="pre">attitude_plotter.</span></span><span class="sig-name descname"><span class="pre">attitude_3d_connect_to_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">title</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Px</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Py</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">60</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['red',</span> <span class="pre">'#12e193',</span> <span class="pre">'red',</span> <span class="pre">'#12e193',</span> <span class="pre">'black',</span> <span class="pre">'blue']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['solid',</span> <span class="pre">'solid',</span> <span class="pre">'solid',</span> <span class="pre">'solid',</span> <span class="pre">'solid',</span> <span class="pre">'solid']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lw</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[2.5,</span> <span class="pre">2.5,</span> <span class="pre">2.5,</span> <span class="pre">2.5,</span> <span class="pre">2,</span> <span class="pre">2]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arrlen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.5,</span> <span class="pre">0.5,</span> <span class="pre">0.5,</span> <span class="pre">0.5,</span> <span class="pre">1,</span> <span class="pre">1]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['$Dipole_{1}$',</span> <span class="pre">'$Dipole_{2}$',</span> <span class="pre">'Boresight',</span> <span class="pre">'$Ray_{LOS}$',</span> <span class="pre">'N',</span> <span class="pre">'S']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">markers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['_',</span> <span class="pre">'_',</span> <span class="pre">'$\\longrightarrow$',</span> <span class="pre">'$\\longrightarrow$',</span> <span class="pre">'H',</span> <span class="pre">'H']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['red',</span> <span class="pre">'#12e193',</span> <span class="pre">'black',</span> <span class="pre">'blue',</span> <span class="pre">'None',</span> <span class="pre">'black']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edgecolors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['red',</span> <span class="pre">'#12e193',</span> <span class="pre">'black',</span> <span class="pre">'blue',</span> <span class="pre">'black',</span> <span class="pre">'black']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arrowhead</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.01,</span> <span class="pre">0.01,</span> <span class="pre">0.01,</span> <span class="pre">0.01,</span> <span class="pre">0.25,</span> <span class="pre">0.25]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sct_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{'alpha':</span> <span class="pre">1,</span> <span class="pre">'c':</span> <span class="pre">'lightgrey',</span> <span class="pre">'edgecolor':</span> <span class="pre">'black',</span> <span class="pre">'marker':</span> <span class="pre">'*',</span> <span class="pre">'s':</span> <span class="pre">180}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'upper</span> <span class="pre">center'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#attitude_plotter.attitude_3d_connect_to_target" title="Permalink to this definition"></a></dt>
<dd><p>Plotting function in 3D to connect the spacecraft location with the target.
The defaults for the keywords are based on RRI plots.</p>
<dl class="simple">
<dt>title<span class="classifier">str</span></dt><dd><p>plot title.</p>
</dd>
<dt>time_array<span class="classifier">datetime.datetime</span></dt><dd><p>experiment time interval as datetime array.</p>
</dd>
<dt>Px<span class="classifier">float</span></dt><dd><p>geodetic longitude of the target.</p>
</dd>
<dt>Py<span class="classifier">float</span></dt><dd><p>geodetic latitude of the target.</p>
</dd>
<dt>Pz<span class="classifier">float</span></dt><dd><p>altitude of the target (km).</p>
</dd>
<dt>x<span class="classifier">numpy.ndarray</span></dt><dd><p>spacecraft longitude.</p>
</dd>
<dt>y<span class="classifier">numpy.ndarray</span></dt><dd><p>spacecraft latitude.</p>
</dd>
<dt>z<span class="classifier">numpy.ndarray</span></dt><dd><p>spacecraft altitude.</p>
</dd>
<dt>target_name<span class="classifier">str</span></dt><dd><p>target name.</p>
</dd>
<dt><a href="#id7"><span class="problematic" id="id8">*</span></a>V<span class="classifier">numpy.ndarray</span></dt><dd><p>vectors to be plotted (need to be in ENU coordinate system).
vec_args = M1_enu, M3_enu, M2_enu, M4_enu, RRI_enu, los_enu_arr</p>
</dd>
<dt>step<span class="classifier">int</span></dt><dd><p>time between the vectors. The default is 60. (60 seconds)</p>
</dd>
<dt>vc<span class="classifier">list, optional</span></dt><dd><p>vector colors. The default is [‘red’, ‘#12e193’, ‘red’, ‘#12e193’,                                       ‘black’, ‘blue’].</p>
</dd>
<dt>ls<span class="classifier">list, optional</span></dt><dd><p>linestyles for vectors. The default is [‘solid’, ‘solid’, ‘solid’,                                                ‘solid’, ‘solid’, ‘solid’].</p>
</dd>
<dt>lw<span class="classifier">list, optional</span></dt><dd><p>linewidth of vectors. The default is [2.5, 2.5, 2.5, 2.5, 2, 2].</p>
</dd>
<dt>arrlen<span class="classifier">list, optional</span></dt><dd><p>length for vectors. The default is [0.5, 0.5, 0.5, 0.5, 1, 1].</p>
</dd>
<dt>labels<span class="classifier">list, optional</span></dt><dd><p>vector labels for legend. The default is [‘$Dipole_{1}$’,                                                  ‘$Dipole_{2}$’, ‘Boresight’,                                                      ‘$Ray_{LOS}$’].</p>
</dd>
<dt>markers<span class="classifier">list, optional</span></dt><dd><p>legend markers. The default is [‘_’,’_’,  r’$longrightarrow$’,                                        r’$longrightarrow$’].</p>
</dd>
<dt>colors<span class="classifier">list, optional</span></dt><dd><p>colors for labels in the legend. The default is [‘red’, ‘#12e193’,                                                         ‘black’, ‘blue’].</p>
</dd>
<dt>edgecolors<span class="classifier">list, optional</span></dt><dd><p>edgecolors for labels in the legend. The default is [‘red’, ‘#12e193’,                                                             ‘black’,’blue’].</p>
</dd>
<dt>arrowhead<span class="classifier">list, optional</span></dt><dd><p>how large is the arrow head. The default is [0.01, 0.01, 0.01, 0.01,                                                      0.25, 0.25].</p>
</dd>
<dt>sct_kwargs<span class="classifier">dict, optional</span></dt><dd><p>target marker specifics.The default is {‘alpha’: 1,                                                ‘edgecolor’:’black’,                                                ‘c’: ‘lightgrey’,                                                 ‘marker’: ‘*’, ‘s’: 180}.</p>
</dd>
<dt>loc<span class="classifier">str, optional</span></dt><dd><p>Location of the legend. The default is ‘upper center’.</p>
</dd>
</dl>
<dl class="simple">
<dt>fig<span class="classifier">figure.Figure</span></dt><dd><p>Figure object of matplotlib.figure module.</p>
</dd>
<dt>ax<span class="classifier">axes</span></dt><dd><p>Axes object of matplotlib.</p>
</dd>
</dl>
<p>vec_args= M1_enu, M3_enu, M2_enu, M4_enu, RRI_enu, los_enu_arr
connected_plot, ax = ap.attitude_3d_connect_to_target(title_vec,                                                      time_array_1sec,                                                     pLon, pLat, pH,                                                      Lon, Lat, Alt,                                                     target_name,                                                     <a href="#id9"><span class="problematic" id="id10">*</span></a>vec_args, step = 45)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="attitude_plotter.attitude_3d_ground_quiver">
<span class="sig-prename descclassname"><span class="pre">attitude_plotter.</span></span><span class="sig-name descname"><span class="pre">attitude_3d_ground_quiver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">title</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Px</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Py</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dir_vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">60</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['red',</span> <span class="pre">'#12e193',</span> <span class="pre">'red',</span> <span class="pre">'#12e193',</span> <span class="pre">'black',</span> <span class="pre">'#0165fc']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arrlen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.25,</span> <span class="pre">0.25,</span> <span class="pre">0.25,</span> <span class="pre">0.25,</span> <span class="pre">0.75,</span> <span class="pre">0.75]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['solid',</span> <span class="pre">'solid',</span> <span class="pre">'solid',</span> <span class="pre">'solid',</span> <span class="pre">'solid',</span> <span class="pre">'solid']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['$Dipole_{1}$',</span> <span class="pre">'$Dipole_{2}$',</span> <span class="pre">'Boresight',</span> <span class="pre">'$Ray_{LOS}$']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">markers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['_',</span> <span class="pre">'$--$',</span> <span class="pre">'$\\longrightarrow$',</span> <span class="pre">'$\\longrightarrow$',</span> <span class="pre">'H',</span> <span class="pre">'H']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legend_colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['red',</span> <span class="pre">'#12e193',</span> <span class="pre">'black',</span> <span class="pre">'#0165fc',</span> <span class="pre">'None',</span> <span class="pre">'black']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legend_edgecolors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['red',</span> <span class="pre">'#12e193',</span> <span class="pre">'black',</span> <span class="pre">'#0165fc',</span> <span class="pre">'black',</span> <span class="pre">'black']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'upper</span> <span class="pre">center'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#attitude_plotter.attitude_3d_ground_quiver" title="Permalink to this definition"></a></dt>
<dd><p>Plotting function to show projected look direction of RRI on the ground.
The defaults for the keywords are based on RRI plots.</p>
<dl class="simple">
<dt>title<span class="classifier">str</span></dt><dd><p>plot title.</p>
</dd>
<dt>time_array<span class="classifier">datetime.datetime</span></dt><dd><p>experiment time interval as datetime array.</p>
</dd>
<dt>Px<span class="classifier">float</span></dt><dd><p>geodetic longitude of the target.</p>
</dd>
<dt>Py<span class="classifier">float</span></dt><dd><p>geodetic latitude of the target.</p>
</dd>
<dt>Pz<span class="classifier">float</span></dt><dd><p>altitude of the target.</p>
</dd>
<dt>x<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft longitude.</p>
</dd>
<dt>y<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft latitude.</p>
</dd>
<dt>z<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft altitude.</p>
</dd>
<dt>dir_vec<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>look direction vector in ENU.</p>
</dd>
<dt>target_name<span class="classifier">str</span></dt><dd><p>target name.</p>
</dd>
<dt><a href="#id11"><span class="problematic" id="id12">*</span></a>V<span class="classifier">numpy.ndarray</span></dt><dd><p>vectors to be plotted (need to be in ENU coordinate system).
vec_args = M1_enu, M3_enu, M2_enu, M4_enu, RRI_enu, los_enu_arr</p>
</dd>
<dt>step<span class="classifier">float, optional</span></dt><dd><p>Step in seconds to plot vectors. The default is 60.</p>
</dd>
<dt>vc<span class="classifier">list, optional</span></dt><dd><p>vector colors. 
The default is [‘red’,’#12e193’, ‘red’, ‘#12e193’, ‘black’, ‘#0165fc’].</p>
</dd>
<dt>arrlen<span class="classifier">TYPE, optional</span></dt><dd><p>DESCRIPTION. 
The default is [0.25, 0.25, 0.25, 0.25, 0.75, 0.75].</p>
</dd>
<dt>ls<span class="classifier">list, optional</span></dt><dd><p>linestyles for vectors.
The default is [‘solid’, ‘solid’, ‘solid’, ‘solid’,’solid’,  ‘solid’].</p>
</dd>
<dt>labels<span class="classifier">list, optional</span></dt><dd><p>vector labels for legend.
The default is [‘$Dipole_{1}$’,’$Dipole_{2}$’,’Boresight’’$Ray_{LOS}$’].</p>
</dd>
<dt>markers<span class="classifier">list, optional</span></dt><dd><p>legend markers.
The default is [‘_’,’$–$’,r’$longrightarrow$’,                        r’$longrightarrow$’,’H’,’H’].</p>
</dd>
<dt>legend_colors<span class="classifier">list, optional</span></dt><dd><p>colors for labels in the legend. 
The default is [‘red’, ‘#12e193’,’black’,’#0165fc’ ,’None’, ‘black’].</p>
</dd>
<dt>legend_edgecolors<span class="classifier">list, optional</span></dt><dd><p>edgecolors for labels in the legend.
The default is [‘red’, ‘#12e193’,’black’,’#0165fc’ ,’black’, ‘black’].</p>
</dd>
<dt>loc<span class="classifier">str</span></dt><dd><p>legend location. uses same keywords as matplotlib legend.
The default is ‘upper center’.</p>
</dd>
</dl>
<dl class="simple">
<dt>fig<span class="classifier">figure.Figure</span></dt><dd><p>Figure object of matplotlib.figure module.</p>
</dd>
<dt>ax<span class="classifier">axes</span></dt><dd><p>Axes object of matplotlib.</p>
</dd>
</dl>
<p>V = M1_enu, M3_enu, M2_enu, M4_enu, RRI_enu, los_enu_arr
ground_quiver_3d = op.attitude_3d_ground_quiver(title, time_array,                                                  pLon, pLat, OH,                                                   Lon, Lat, Alt, RRI_enu,</p>
<blockquote>
<div><p>‘Ottawa’, <a href="#id13"><span class="problematic" id="id14">*</span></a>V, step = 60)</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="attitude_plotter.display_observation_geometry">
<span class="sig-prename descclassname"><span class="pre">attitude_plotter.</span></span><span class="sig-name descname"><span class="pre">display_observation_geometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">title</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Px</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Py</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">60</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['red',</span> <span class="pre">'#12e193',</span> <span class="pre">'red',</span> <span class="pre">'#12e193',</span> <span class="pre">'black',</span> <span class="pre">'blue']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['solid',</span> <span class="pre">'solid',</span> <span class="pre">'solid',</span> <span class="pre">'solid',</span> <span class="pre">'solid',</span> <span class="pre">'solid']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lw</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[1.5,</span> <span class="pre">1.5,</span> <span class="pre">1.5,</span> <span class="pre">1.5,</span> <span class="pre">1.5,</span> <span class="pre">1.5]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arrlen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.5,</span> <span class="pre">0.5,</span> <span class="pre">0.5,</span> <span class="pre">0.5,</span> <span class="pre">0.75,</span> <span class="pre">1]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['$Dipole_{1}$',</span> <span class="pre">'$Dipole_{2}$',</span> <span class="pre">'Boresight',</span> <span class="pre">'$Ray_{LOS}$']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">markers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['_',</span> <span class="pre">'_',</span> <span class="pre">'$\\longrightarrow$',</span> <span class="pre">'$\\longrightarrow$']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['red',</span> <span class="pre">'#12e193',</span> <span class="pre">'black',</span> <span class="pre">'blue']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edgecolors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['red',</span> <span class="pre">'#12e193',</span> <span class="pre">'black',</span> <span class="pre">'blue']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arrowhead</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.01,</span> <span class="pre">0.01,</span> <span class="pre">0.01,</span> <span class="pre">0.01,</span> <span class="pre">0.45,</span> <span class="pre">0.45]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sct_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{'alpha':</span> <span class="pre">1,</span> <span class="pre">'c':</span> <span class="pre">'lightgrey',</span> <span class="pre">'edgecolor':</span> <span class="pre">'black',</span> <span class="pre">'marker':</span> <span class="pre">'*',</span> <span class="pre">'s':</span> <span class="pre">180}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'upper</span> <span class="pre">center'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#attitude_plotter.display_observation_geometry" title="Permalink to this definition"></a></dt>
<dd><p>Plotting function to display observation geometry.
The defaults for the keywords are based on RRI plots.</p>
<dl class="simple">
<dt>title<span class="classifier">str</span></dt><dd><p>plot title.</p>
</dd>
<dt>time_array<span class="classifier">datetime.datetime</span></dt><dd><p>experiment time interval as datetime array.</p>
</dd>
<dt>Px<span class="classifier">float</span></dt><dd><p>geodetic longitude of the target.</p>
</dd>
<dt>Py<span class="classifier">float</span></dt><dd><p>geodetic latitude of the target.</p>
</dd>
<dt>Pz<span class="classifier">float</span></dt><dd><p>altitude of the target.</p>
</dd>
<dt>x<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft longitude(degrees).</p>
</dd>
<dt>y<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft latitude (degrees).</p>
</dd>
<dt>z<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft altitude (km).</p>
</dd>
<dt>target_name<span class="classifier">str</span></dt><dd><p>target name.</p>
</dd>
<dt><a href="#id15"><span class="problematic" id="id16">*</span></a>V<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>vectors to be plotted (need to be in ENU coordinate system).
vec_args = M1_enu, M3_enu, M2_enu, M4_enu, RRI_enu, los_enu_arr</p>
</dd>
<dt>step<span class="classifier">int</span></dt><dd><p>time between the vectors. The default is 60. (60 seconds)</p>
</dd>
<dt>vc<span class="classifier">list, optional</span></dt><dd><p>vector colors. The default is [‘red’, ‘#12e193’, ‘red’, ‘#12e193’,                                       ‘black’, ‘blue’].</p>
</dd>
<dt>ls<span class="classifier">list, optional</span></dt><dd><p>linestyles for vectors. The default is [‘solid’, ‘solid’, ‘solid’,                                                ‘solid’, ‘solid’, ‘solid’].</p>
</dd>
<dt>lw<span class="classifier">list, optional</span></dt><dd><p>linewidth of vectors. The default is [1.5, 1.5, 1.5, 1.5, 1.5, 1.5].</p>
</dd>
<dt>arrlen<span class="classifier">list, optional</span></dt><dd><p>length for vectors. The default is [.5, .5, .5, .5, .75, 1].</p>
</dd>
<dt>labels<span class="classifier">list, optional</span></dt><dd><p>vector labels for legend. The default is [‘$Dipole_{1}$’,                                                  ‘$Dipole_{2}$’, ‘Boresight’,                                                      ‘$Ray_{LOS}$’].</p>
</dd>
<dt>markers<span class="classifier">list, optional</span></dt><dd><p>legend markers. The default is [‘_’,’_’,  r’$longrightarrow$’,                                        r’$longrightarrow$’].</p>
</dd>
<dt>colors<span class="classifier">list, optional</span></dt><dd><p>colors for labels in the legend. The default is [‘red’, ‘#12e193’,                                                         ‘black’, ‘blue’].</p>
</dd>
<dt>edgecolors<span class="classifier">list, optional</span></dt><dd><p>edgecolors for labels in the legend. The default is [‘red’, ‘#12e193’,                                                             ‘black’,’blue’].</p>
</dd>
<dt>arrowhead<span class="classifier">list, optional</span></dt><dd><p>how large is the arrow head. The default is [0.01, 0.01, 0.01, 0.01,                                                      0.45, 0.45].</p>
</dd>
<dt>sct_kwargs<span class="classifier">dict, optional</span></dt><dd><p>target marker specifics.The default is {‘alpha’: 1,                                                ‘edgecolor’:’black’,                                                ‘c’: ‘lightgrey’,                                                 ‘marker’: ‘*’, ‘s’: 180}.</p>
</dd>
<dt>loc<span class="classifier">str</span></dt><dd><p>legend location. uses same keywords as matplotlib legend.             The default is ‘upper right’.</p>
</dd>
</dl>
<dl class="simple">
<dt>fig<span class="classifier">figure.Figure</span></dt><dd><p>Figure object of matplotlib.figure module.</p>
</dd>
<dt>ax<span class="classifier">axes</span></dt><dd><p>Axes object of matplotlib.</p>
</dd>
</dl>
<p>vec_args= M1_enu, M3_enu, M2_enu, M4_enu, RRI_enu, los_enu_arr
connected_plot = op.display_observation_geometry(title_vec,                                                      time_array_1sec,                                                     pLon, pLat, OH,                                                      Lon, Lat, Alt,                                                     ‘Ottawa’, <a href="#id17"><span class="problematic" id="id18">*</span></a>vec_args, n=45)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="attitude_plotter.earth_radius_at_latitude">
<span class="sig-prename descclassname"><span class="pre">attitude_plotter.</span></span><span class="sig-name descname"><span class="pre">earth_radius_at_latitude</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latitude</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#attitude_plotter.earth_radius_at_latitude" title="Permalink to this definition"></a></dt>
<dd><p>Function to calculate Earth radius at latitude to correctly scale 
the ellipse height for FOV plotter.</p>
<dl class="simple">
<dt>latitude<span class="classifier">float</span></dt><dd><p>Geodetic latitude (degrees).</p>
</dd>
</dl>
<dl class="simple">
<dt>R<span class="classifier">float</span></dt><dd><p>Earth’s radius in meters.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="attitude_plotter.fov_plotter">
<span class="sig-prename descclassname"><span class="pre">attitude_plotter.</span></span><span class="sig-name descname"><span class="pre">fov_plotter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">extent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fov_deg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Px</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Py</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vec_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inst_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">90</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_arrow</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_factor_shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#attitude_plotter.fov_plotter" title="Permalink to this definition"></a></dt>
<dd><p>Plot the FOV of the instrument.</p>
<dl class="simple">
<dt>extent<span class="classifier">list</span></dt><dd><p>[Lonmin, Lonmax, Latmin, Latmax].</p>
</dd>
<dt>time_array<span class="classifier">numpy.ndarray[datetime]</span></dt><dd><p>Experiment time interval.</p>
</dd>
<dt>alt<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Spacecraft altitude (km).</p>
</dd>
<dt>lat<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Spacecraft latitude (degrees).</p>
</dd>
<dt>lon<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Spacecraft longitude (degrees).</p>
</dd>
<dt>fov_deg<span class="classifier">float</span></dt><dd><p>Field-of-view angle (degrees).</p>
</dd>
<dt>Px<span class="classifier">float</span></dt><dd><p>Target longitude (degrees).</p>
</dd>
<dt>Py<span class="classifier">float</span></dt><dd><p>Target latitude (degrees).</p>
</dd>
<dt>vec<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Instrument pointing vector in East-North-Center(ENC) coordinates.</p>
</dd>
<dt>vec_elev<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Elevation angle (degrees).</p>
</dd>
<dt>inst_name<span class="classifier">string</span></dt><dd><p>Name of the instrument.</p>
</dd>
<dt>target_name<span class="classifier">string</span></dt><dd><p>Ground target to be captured.</p>
</dd>
<dt>step<span class="classifier">float, optional</span></dt><dd><p>Time interval in seconds to plot the inst. vector. The default is 90.</p>
</dd>
<dt>scale_arrow<span class="classifier">float, optional</span></dt><dd><p>Scaling of the inst. vector. The default is 20.</p>
</dd>
<dt>scale_factor_shift<span class="classifier">float, optional</span></dt><dd><p>Scale factor to shift the ellipse center location. The default is 2.5.</p>
</dd>
</dl>
<dl class="simple">
<dt>ax<span class="classifier">TYPE</span></dt><dd><p>DESCRIPTION.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="attitude_plotter.plot_attitude_accuracy">
<span class="sig-prename descclassname"><span class="pre">attitude_plotter.</span></span><span class="sig-name descname"><span class="pre">plot_attitude_accuracy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_RRI</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#attitude_plotter.plot_attitude_accuracy" title="Permalink to this definition"></a></dt>
<dd><p>Plots the attitude accuracy using the accuracy data in RRI data files.
0=Dropout, 1=Rough, 2=Coarse, 3=Moderate, 4=Fine, 9=NaN.</p>
<dl class="simple">
<dt>file_RRI<span class="classifier">str</span></dt><dd><p>Filename of the RRI data file including the path.</p>
</dd>
</dl>
<dl class="simple">
<dt>fig<span class="classifier">figure.Figure</span></dt><dd><p>Figure object of matplotlib.figure module.</p>
</dd>
<dt>ax<span class="classifier">axes</span></dt><dd><p>Axes object of matplotlib.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="attitude_plotter.plot_slew_rri">
<span class="sig-prename descclassname"><span class="pre">attitude_plotter.</span></span><span class="sig-name descname"><span class="pre">plot_slew_rri</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylim_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylim_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">panel_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slew</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slew_angle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cb_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'no'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'no'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#attitude_plotter.plot_slew_rri" title="Permalink to this definition"></a></dt>
<dd><p>Function to plot the temporal change of slew accuracy for the criterion
set by slew_angle.</p>
<dl class="simple">
<dt>ax<span class="classifier">axes</span></dt><dd><p>Axes object of matplotlib.</p>
</dd>
<dt>ylim_min<span class="classifier">float</span></dt><dd><p>DESCRIPTION.</p>
</dd>
<dt>ylim_max<span class="classifier">float</span></dt><dd><p>DESCRIPTION.</p>
</dd>
<dt>panel_number<span class="classifier">int</span></dt><dd><p>panel number in slew criteria plot.</p>
</dd>
<dt>time_array<span class="classifier">datetime.datetime</span></dt><dd><p>experiment time interval as datetime array.</p>
</dd>
<dt>slew<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>slew parameter. Can be [-2, -1, -0.5, 0, 0.5, 1, 2]</p>
</dd>
<dt>slew_angle<span class="classifier">float</span></dt><dd><p>criteria for slew (degrees).</p>
</dd>
<dt>cb_axis<span class="classifier">str, optional</span></dt><dd><p>color bar axes display (‘yes’/’no’). The default is ‘no’.</p>
</dd>
<dt>time<span class="classifier">str, optional</span></dt><dd><p>x-axis time display (‘yes’/’no’). The default is ‘no’.</p>
</dd>
</dl>
<p>None.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="attitude_plotter.trajectory_plotter_2d_map">
<span class="sig-prename descclassname"><span class="pre">attitude_plotter.</span></span><span class="sig-name descname"><span class="pre">trajectory_plotter_2d_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Px</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Py</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">XV</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index_ca</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#attitude_plotter.trajectory_plotter_2d_map" title="Permalink to this definition"></a></dt>
<dd><p>Plots the spacecraft trajectory on map.
Prints the trajectory information on screen: altitude increasing/decreasing
spacecraft going towards: NE, SW, NW, SE.</p>
<dl class="simple">
<dt>time_array<span class="classifier">datetime.datetime</span></dt><dd><p>experiment time interval as datetime array.</p>
</dd>
<dt>extent<span class="classifier">TYPE</span></dt><dd><p>DESCRIPTION.</p>
</dd>
<dt>x<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft longitude(degrees).</p>
</dd>
<dt>y<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft latitude (degrees).</p>
</dd>
<dt>z<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>spacecraft altitude (km).</p>
</dd>
<dt>Px<span class="classifier">float</span></dt><dd><p>geodetic longitude of the target.</p>
</dd>
<dt>Py<span class="classifier">float</span></dt><dd><p>geodetic latitude of the target.</p>
</dd>
<dt>target_name<span class="classifier">str</span></dt><dd><p>Target name for labels.</p>
</dd>
<dt>index_ca<span class="classifier">int</span></dt><dd><p>index of the point of closest approach. can be found by using 
miscellaneous.find_index</p>
</dd>
</dl>
<dl class="simple">
<dt>fig<span class="classifier">figure.Figure</span></dt><dd><p>Figure object of matplotlib.figure module.</p>
</dd>
<dt>ax<span class="classifier">axes</span></dt><dd><p>Axes object of matplotlib.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="miscellaneous-utilities">
<h1>miscellaneous: Utilities<a class="headerlink" href="#miscellaneous-utilities" title="Permalink to this heading"></a></h1>
<span class="target" id="module-miscellaneous"></span><p>This module contains functions for: 
1- legend insertion to figures (put_legend, put_legend_fnt)
2- combining images (combine_horizontal, combine_vertical)
3- marking specific times on map(mark_on_map, mark_beginning_on_map)</p>
<blockquote>
<div><p>and altitude plots(mark_beginning, mark_altitude_plots)</p>
</div></blockquote>
<p>4- plotting the direction of the spacecraft
5- finding index of desired values in parameters: find_index</p>
<p>&#64;author: ceren</p>
<dl class="py function">
<dt class="sig sig-object py" id="miscellaneous.combine_horizontal">
<span class="sig-prename descclassname"><span class="pre">miscellaneous.</span></span><span class="sig-name descname"><span class="pre">combine_horizontal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fnew</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#miscellaneous.combine_horizontal" title="Permalink to this definition"></a></dt>
<dd><p>Horizontally combines images with arbitrary image size as a new image and
saves the new image with the given file name.</p>
<p>f: Name of image files, list
fnew: Output file name</p>
<p>Saves horizontally combined image as fnew to the directory
Reference: <a class="reference external" href="https://stackoverflow.com/a/30228789/15165141">https://stackoverflow.com/a/30228789/15165141</a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="miscellaneous.combine_vertical">
<span class="sig-prename descclassname"><span class="pre">miscellaneous.</span></span><span class="sig-name descname"><span class="pre">combine_vertical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fnew</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#miscellaneous.combine_vertical" title="Permalink to this definition"></a></dt>
<dd><p>Vertically combines images with arbitrary image size as a new image and
saves the new image with the given file name.</p>
<p>f: Name of image files, list
fnew: Output file name</p>
<p>Saves vertically combined image as fnew to the directory
Reference: <a class="reference external" href="https://stackoverflow.com/a/30228789/15165141">https://stackoverflow.com/a/30228789/15165141</a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="miscellaneous.coverage">
<span class="sig-prename descclassname"><span class="pre">miscellaneous.</span></span><span class="sig-name descname"><span class="pre">coverage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">extent</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#miscellaneous.coverage" title="Permalink to this definition"></a></dt>
<dd><p>Generates the plot parameters</p>
<dl class="simple">
<dt>extent: list</dt><dd><p>[Lon_min, Lon_max, Lat_min, Lat_max]</p>
</dd>
</dl>
<dl class="simple">
<dt>central_lon<span class="classifier">float</span></dt><dd><p>Central longitude (degrees)</p>
</dd>
<dt>central lat<span class="classifier">float</span></dt><dd><p>Central latitude (degrees)</p>
</dd>
<dt>pre-defined<span class="classifier">float</span></dt><dd><p>left (.01), width (.5), bottom (.01), height (.5)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="miscellaneous.find_index">
<span class="sig-prename descclassname"><span class="pre">miscellaneous.</span></span><span class="sig-name descname"><span class="pre">find_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">closeto</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'off'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#miscellaneous.find_index" title="Permalink to this definition"></a></dt>
<dd><p>Finds the index of numbers that are close to the value we are searching for
with a tolerance ‘tol’.</p>
<dl class="simple">
<dt>data: np.ndarray[float]</dt><dd><p>input data for inspection, array</p>
</dd>
<dt>closeto: float</dt><dd><p>The value we are searching for</p>
</dd>
<dt>tol: float</dt><dd><p>Amount of tolerance</p>
</dd>
<dt>verbose<span class="classifier">string, optional</span></dt><dd><p>Verbose. The default is ‘off’.</p>
</dd>
</dl>
<dl class="simple">
<dt>ind_close: list</dt><dd><p>Index of the close values</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="miscellaneous.indices_and_intervals">
<span class="sig-prename descclassname"><span class="pre">miscellaneous.</span></span><span class="sig-name descname"><span class="pre">indices_and_intervals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intval</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#miscellaneous.indices_and_intervals" title="Permalink to this definition"></a></dt>
<dd><p>Generates date for usage with plot titles and output filenames,
determines the index of the last used data row and finds the number of
intervals for cases we do not use the complete data set.</p>
<dl class="simple">
<dt>start_time: datetime.datetime</dt><dd><p>The beginning of the passage</p>
</dd>
<dt>time_data<span class="classifier">datetime.datetime </span></dt><dd><p>Time array for the whole passage</p>
</dd>
<dt>intval<span class="classifier">int</span></dt><dd><p>how many seconds do we want for intervals</p>
</dd>
</dl>
<dl class="simple">
<dt>date<span class="classifier">str</span></dt><dd><p>date as a string.</p>
</dd>
<dt>last_data_index: int</dt><dd><p>index of the last used data row</p>
</dd>
<dt>number_of_intervals: int</dt><dd><p>number of intervals for cases</p>
</dd>
<dt>seconds: int</dt><dd><p>tick locator for seconds</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="miscellaneous.mark_altitude_plots">
<span class="sig-prename descclassname"><span class="pre">miscellaneous.</span></span><span class="sig-name descname"><span class="pre">mark_altitude_plots</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Px</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Py</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cyan'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edgecolor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'k'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marker</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'*'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#miscellaneous.mark_altitude_plots" title="Permalink to this definition"></a></dt>
<dd><p>Function to mark locations on altitude plots.</p>
<dl class="simple">
<dt>ax<span class="classifier">Axes</span></dt><dd><p>axes.</p>
</dd>
<dt>Px<span class="classifier">float</span></dt><dd><p>Longitude of the point to be marked (degrees).</p>
</dd>
<dt>Py<span class="classifier">float</span></dt><dd><p>Altitude of the point to be marked (km).</p>
</dd>
<dt>color<span class="classifier">str, optional</span></dt><dd><p>Color of the point to be marked. Default is ‘cyan’.</p>
</dd>
<dt>edgecolor<span class="classifier">str, optional</span></dt><dd><p>Edge color of the point to be marked. Default is ‘black’.</p>
</dd>
<dt>marker<span class="classifier">str, optional</span></dt><dd><p>Marker symbol. The default is start ‘*’.</p>
</dd>
<dt><a href="#id19"><span class="problematic" id="id20">**</span></a>kwargs<span class="classifier">dict</span></dt><dd><p>Additional keyword arguments for scatter plot.</p>
</dd>
</dl>
<p>None.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="miscellaneous.mark_beginning">
<span class="sig-prename descclassname"><span class="pre">miscellaneous.</span></span><span class="sig-name descname"><span class="pre">mark_beginning</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#miscellaneous.mark_beginning" title="Permalink to this definition"></a></dt>
<dd><p>Plot to mark the beginning of the pass and show the direction of the
spacecraft with an arrow for altitude plots.</p>
<dl class="simple">
<dt>ax<span class="classifier">Axes</span></dt><dd><p>axes.</p>
</dd>
<dt>x<span class="classifier">float</span></dt><dd><p>Longitude of the beginning of the trajectory (degrees).</p>
</dd>
<dt>y<span class="classifier">float</span></dt><dd><p>Latitude of the beginning of the trajectory (degrees).</p>
</dd>
<dt>z<span class="classifier">float</span></dt><dd><p>Altitude of the beginning of the trajectory (km).</p>
</dd>
</dl>
<p>None.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="miscellaneous.mark_beginning_on_map">
<span class="sig-prename descclassname"><span class="pre">miscellaneous.</span></span><span class="sig-name descname"><span class="pre">mark_beginning_on_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">cartopy.crs.PlateCarree</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#miscellaneous.mark_beginning_on_map" title="Permalink to this definition"></a></dt>
<dd><p>Function to mark the beginning of the pass and tp show the direction of the
spacecraft with an arrow on map projections.</p>
<dl class="simple">
<dt>ax<span class="classifier">Axes</span></dt><dd><p>axes.</p>
</dd>
<dt>x<span class="classifier">float</span></dt><dd><p>Longitude of the beginning of the trajectory (degrees).</p>
</dd>
<dt>y<span class="classifier">float</span></dt><dd><p>Latitude of the beginning of the trajectory (degrees).</p>
</dd>
<dt>z<span class="classifier">float, optional</span></dt><dd><p>Latitude of the beginning of the trajectory (km).</p>
</dd>
<dt>transform<span class="classifier">object, optional</span></dt><dd><p>cartopy projection. The default is ccrs.PlateCarree().</p>
</dd>
</dl>
<p>None.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="miscellaneous.mark_on_map">
<span class="sig-prename descclassname"><span class="pre">miscellaneous.</span></span><span class="sig-name descname"><span class="pre">mark_on_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Px</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Py</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cyan'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edgecolor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'black'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marker</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'*'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">cartopy.crs.PlateCarree</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#miscellaneous.mark_on_map" title="Permalink to this definition"></a></dt>
<dd><p>Function to mark locations on maps.</p>
<dl class="simple">
<dt>ax<span class="classifier">Axes</span></dt><dd><p>axes.</p>
</dd>
<dt>Px<span class="classifier">float</span></dt><dd><p>Longitude of the point to be marked (degrees).</p>
</dd>
<dt>Py<span class="classifier">float</span></dt><dd><p>Latitude of the point to be marked (degrees).</p>
</dd>
<dt>color<span class="classifier">str, optional</span></dt><dd><p>Color of the point to be marked. Default is ‘cyan’.</p>
</dd>
<dt>edgecolor<span class="classifier">str, optional</span></dt><dd><p>Edge color of the point to be marked. Default is ‘black’.</p>
</dd>
<dt>transform<span class="classifier">object, optional</span></dt><dd><p>cartopy projection. The default is ccrs.PlateCarree().</p>
</dd>
<dt><a href="#id21"><span class="problematic" id="id22">**</span></a>kwargs<span class="classifier">dict</span></dt><dd><p>Additional keyword arguments for scatter plot.</p>
</dd>
</dl>
<p>None.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="miscellaneous.put_legend_fnt">
<span class="sig-prename descclassname"><span class="pre">miscellaneous.</span></span><span class="sig-name descname"><span class="pre">put_legend_fnt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">location</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labelspace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anchorx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anchory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fontsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linestyles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">markers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edgecolors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#miscellaneous.put_legend_fnt" title="Permalink to this definition"></a></dt>
<dd><p>Inserts legend to figure for cases, which need customized symbols.</p>
<dl class="simple">
<dt>ax: str</dt><dd><p>axis</p>
</dd>
<dt>n: float</dt><dd><p>how many columns should the legend have</p>
</dd>
<dt>location: str</dt><dd><p>location of the legend</p>
</dd>
<dt>labelspace: float</dt><dd><p>space between the labels (values can be between 0 and 1).</p>
</dd>
<dt>anchorx, anchory: float</dt><dd><p>coordinate of the lower left corner of legend box
(values can be between 0 and 1)</p>
</dd>
</dl>
<p>The following are for the customization of the symbols we want to display:</p>
<dl class="simple">
<dt>labels: str</dt><dd><p>labels to display in the legend</p>
</dd>
<dt>linestyles: str</dt><dd><p>linestyles used in plotting the parameters</p>
</dd>
<dt>markers: str</dt><dd><p>markers used in plotting the parameters</p>
</dd>
<dt>colors: str</dt><dd><p>colors used in plotting the parameters.
can be also given in RGB</p>
</dd>
<dt>edgecolors: str</dt><dd><p>edgecolors used in plotting the parameters</p>
</dd>
</dl>
<blockquote>
<div><p>None</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="miscellaneous.sc_direction_plotter">
<span class="sig-prename descclassname"><span class="pre">miscellaneous.</span></span><span class="sig-name descname"><span class="pre">sc_direction_plotter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Alt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#miscellaneous.sc_direction_plotter" title="Permalink to this definition"></a></dt>
<dd><p>Plots an arrow to depict the direction of the spacecraft velocity.
Prints out trajectory information: altitude increasing/decreasing, 
going towards SE, NW, SW, NE.</p>
<dl class="simple">
<dt>ax<span class="classifier">axes</span></dt><dd><p>Axes object of matplotlib.</p>
</dd>
<dt>Lon<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Longitude of the beginning of the trajectory (degrees).</p>
</dd>
<dt>Lat<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Latitude of the beginning of the trajectory (degrees).</p>
</dd>
<dt>Alt<span class="classifier">numpy.ndarray[float]</span></dt><dd><p>Altitude of the beginning of the trajectory (km).</p>
</dd>
</dl>
<p>None.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="miscellaneous.set_3Dplot_limits">
<span class="sig-prename descclassname"><span class="pre">miscellaneous.</span></span><span class="sig-name descname"><span class="pre">set_3Dplot_limits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">P</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coord</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">how_far</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#miscellaneous.set_3Dplot_limits" title="Permalink to this definition"></a></dt>
<dd><p>Generates the limit of axes wrt the selected point on the ground for
3D plots.</p>
<blockquote>
<div><dl class="simple">
<dt>P: float</dt><dd><p>coordinate of the ground point at x, y or z</p>
</dd>
<dt>coord: float</dt><dd><p>lat, lon or alt</p>
</dd>
<dt>how_far: float</dt><dd><p>how far is the axis limit from the point on the ground</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>coord_min: float
coord_max: float</p>
</div></blockquote>
<p>xmin, xmax = set_3Dplot_limits(Px, x)</p>
</dd></dl>

</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, C.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>